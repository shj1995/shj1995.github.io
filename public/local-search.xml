<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何在多线程中保证i++的原子性</title>
    <link href="/2020/09/19/java/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81I++%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <url>/2020/09/19/java/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81I++%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>i++是不是一个原子操作？</p></blockquote><p>相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，围绕四个问题：1.什么是原子性操作;2.i++是不是原子操作;3.它为什么不是原子操作;4.如何保证i++的原子性;</p><span id="more"></span><h1 id="剧透"><a href="#剧透" class="headerlink" title="剧透"></a>剧透</h1><p>文章可能有点长（啰嗦），这里先给结论（也希望大家可以看完，在火车上写了好几个小时🤦‍♂️）：</p><p>在多线程中，保证i++的原子性：</p><ol><li>最简单暴力的办法，通过java锁，<code>synchronized</code>或者<code>lock</code>接口的子类，给对象加锁，保证同时只有一个线程在操作</li><li>通过java并发包下的一个原子操作的工具包，AtomicInteger.compareAndSet()方法实现cas(compare and swap,先比较在替换)，保证处理器在处理i++的时候，是原子操作，同时给变量加上volatile修饰符，保证线程的可见性。</li><li>做法类似方法2，不过用getAndIncrement()代替cas赋值操作.</li></ol><h1 id="什么是原子性"><a href="#什么是原子性" class="headerlink" title="什么是原子性"></a>什么是原子性</h1><p> 原子（Atomic），本意是“不能被继续分割的最小粒子”。原子性在我们计算机中一般表示为<strong>原子操作，即不可被中断的一个或一系列操作</strong>，这个概念在我们的编程语言中，数据库中，和操作系统及处理器中都有出现过。</p><h1 id="i-是不是原子操作"><a href="#i-是不是原子操作" class="headerlink" title="i++是不是原子操作"></a>i++是不是原子操作</h1><p>这个问题的答案很多人都知道，但是我们还是要用事实来说话，看下面代码</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            threadList.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    count++;<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread thread : threadList) &#123;<br>            thread.start();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;count：&quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这个程序的很简单，创建50000个线程，执行相同的任务，每个线程执行1000次i++操作，我们期望的结果是50000*1000=50000000；，但是我执行了三次，结果分别为：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs absh">count: 49764627<br>count: 49729044<br>count: 49584608<br></code></pre></div></td></tr></table></figure><p>大家可以看到，结果并非我们期望的那样，三次结果各不相同，</p><p>为什么</p><h1 id="多线程的i-为什么不是原子操作？"><a href="#多线程的i-为什么不是原子操作？" class="headerlink" title="多线程的i++为什么不是原子操作？"></a>多线程的i++为什么不是原子操作？</h1><h2 id="i-在处理器中是如何执行的"><a href="#i-在处理器中是如何执行的" class="headerlink" title="i++在处理器中是如何执行的"></a>i++在处理器中是如何执行的</h2><p>i++虽然在java中是一条命令，但是它在处理器处理的时候，其实是三条命令:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">i = 1; <span class="hljs-comment">#第一步先从内存中取出i的值</span><br>i + 1 = 1 + 1 = 2; <span class="hljs-comment">#第二步计算 i + 1结果</span><br>i = 2; <span class="hljs-comment">#第三步把结果赋值给i</span><br></code></pre></div></td></tr></table></figure><p>所以如果两个线程同时做i++操作就可能发生下面的情况</p><ol><li>线程一获取i的值 i=1;</li><li>线程二获取i的值 i=1;</li><li>线程一计算i+1结果： i+1=1+1=2; </li><li>线程一把结果赋值给i：i+1=1+1=2; </li><li>线程二计算i+1结果： i+1=1+1=2; </li><li>线程二把结果赋值给i：i+1=1+1=2; </li></ol><p>最终就会导致两个线程执行完，i的值等于2,解决这个问题，就需要借助我们的并发包下面的原子操作类了，在java中，有很多原子操作类，它们都在 <code>java.util.concurrent.atomic</code> 这个包下面，比如：<code>AtomicBoolean.java</code>,<code>AtomicInteger.java</code>,<code>AtomicLong.java</code>等等。<br>我们来试一下用<code>AtomicBoolean.java</code>来重构一下我们的程序，看看结果如何</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            threadList.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    count.getAndIncrement();<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread thread : threadList) &#123;<br>            thread.start();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;atomicCount&quot;</span> + count.get());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>同样执行三次，看一下结果：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">atomicCount</span>: <span class="hljs-number">49976284</span><br><span class="hljs-attribute">atomicCount</span>: <span class="hljs-number">49989257</span><br><span class="hljs-attribute">atomicCount</span>: <span class="hljs-number">49976830</span><br><br></code></pre></div></td></tr></table></figure><p>哪这个结果和上面的结果对比一下，大家会发现，咦？结果离我们预期的稍微有点接近哎。那是因为我们解决了i++在处理器中的原子操作问题，然后看下一个问题</p><h2 id="多线程的变量可见性问题"><a href="#多线程的变量可见性问题" class="headerlink" title="多线程的变量可见性问题"></a>多线程的变量可见性问题</h2><p>这里需要先介绍一个java关键字，<code>volatile</code>,volatile是一个轻量级的synchronized,它的作用是在多线程编程中，保证<strong>变量的可见性</strong>，变量可见性就是说当一个线程修改了某个变量，其他线程并不一定会及时的取到变量值，因为每个线程都有自己本地的变量池。关于为啥在多线程编程中会有变量可见性问题，以及<code>volatile</code>和<code>synchronized</code>的原理, 如果有人感兴趣的话，我可以在新的文章里写，这里就不多说了。</p><p>那么我们用<code>volatile</code>来重写一下我们的程序</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            threadList.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    count.getAndIncrement();<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread thread : threadList) &#123;<br>            thread.start();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;atomicCount&quot;</span> + count.get());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java中把一个list转tree的三种方法</title>
    <link href="/2020/03/21/java/java%E4%B8%AD%E6%8A%8A%E4%B8%80%E4%B8%AAlist%E8%BD%ACtree%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2020/03/21/java/java%E4%B8%AD%E6%8A%8A%E4%B8%80%E4%B8%AAlist%E8%BD%ACtree%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>i++是不是一个原子操作？<br>相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，三个问题：1.什么是原子性操作，2，i++是不是原子操作，3，它为什么不是原子操作，4，如何保证i++的原子性</p></blockquote><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>周二面试中，面试官提了一个问题，当时答得不是特别好，手写代码能力还是不行啊，一个是比较紧张，一个是代码没法调试，写递归的时候给自己绕晕了。下面是问题：</p><blockquote><p>我们有个需求，数据库要存一个无限级联的tree，比如菜单，或者地区等数据，现有两个问题，1.问如何设计表，2.怎么返回给前端一个无线级联的json数据；</p></blockquote><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>第一个问题，设计表的话，拿地区举例子,这个只要有id，parentId，就没啥问题。主要是第二个问题</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> Zone &#123;<br>    id <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>    code <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>    parentId <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第二个问题，我的想法是通过一个sql查询查出来所有数据，得到一个 Zone集合，然后就回到了主题，如何用java把list转tree。我第一想法是递归。递归的话，需要考虑几个因素，1.终止条件；2.处理逻辑，3.参数（数据参数，当前层级），4.返回值，然后套入这个问题，分析如下：</p><ol><li>中断条件：当前节点，无子节点，终止退出</li><li>处理逻辑：根据parentId查找节点，设置到parent的children属性中</li><li>参数：数据就是list集合，当前层级参数是parent节点</li><li>无</li></ol><hr><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先我们需要一些辅助类，代码如下（避免代码冗长，我就不写get，set方法了，理解意思就行，实际项目中肯定不能写么写）</p><p>地区类：Zone.class</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zone</span> </span>&#123;<br>    String id;<br>    String name;<br>    String parentId;<br>    List&lt;Test.Zone&gt; children;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Zone</span><span class="hljs-params">(String id, String name, String parentId)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.parentId = parentId;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addChildren</span><span class="hljs-params">(Zone zone)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(children == <span class="hljs-keyword">null</span>) &#123;<br>            children = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        &#125;<br>        children.add(zone);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>测试类：Test.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Zone&gt; zoneList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        zoneList.add(<span class="hljs-keyword">new</span> Zone(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;上海&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>));<br>        zoneList.add(<span class="hljs-keyword">new</span> Zone(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;北京&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>));<br>        zoneList.add(<span class="hljs-keyword">new</span> Zone(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;河南&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>));<br>        zoneList.add(<span class="hljs-keyword">new</span> Zone(<span class="hljs-string">&quot;31&quot;</span>,<span class="hljs-string">&quot;郑州&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>));<br>        zoneList.add(<span class="hljs-keyword">new</span> Zone(<span class="hljs-string">&quot;32&quot;</span>,<span class="hljs-string">&quot;洛阳&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>));<br>        zoneList.add(<span class="hljs-keyword">new</span> Zone(<span class="hljs-string">&quot;321&quot;</span>,<span class="hljs-string">&quot;洛龙&quot;</span>,<span class="hljs-string">&quot;32&quot;</span>));<br>        zoneList.add(<span class="hljs-keyword">new</span> Zone(<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;松江&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>));<br>        zoneList.add(<span class="hljs-keyword">new</span> Zone(<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-string">&quot;泗泾&quot;</span>,<span class="hljs-string">&quot;11&quot;</span>));<br>        List&lt;Zone&gt; rootZone1 = ZoneUtils.buildTree1(zoneList); <span class="hljs-comment">// 测试第一种方法</span><br>        List&lt;Zone&gt; rootZone2 = ZoneUtils.buildTree2(zoneList); <span class="hljs-comment">// 测试第二种方法</span><br>        List&lt;Zone&gt; rootZone3 = ZoneUtils.buildTree3(zoneList); <span class="hljs-comment">// 测试第三种方法</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>地区工具类，提供三种构建tree的方法：ZoneUtils.java</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZoneUtils</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Zone&gt; <span class="hljs-title">buildTree1</span><span class="hljs-params">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO : 第一种解法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Zone&gt; <span class="hljs-title">buildTree2</span><span class="hljs-params">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO : 第二种解法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Zone&gt; <span class="hljs-title">buildTree3</span><span class="hljs-params">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO : 第三种解法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h1 id="第一种方法：递归"><a href="#第一种方法：递归" class="headerlink" title="第一种方法：递归"></a>第一种方法：递归</h1><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Zone&gt; <span class="hljs-title">buildTree1</span><span class="hljs-params">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    List&lt;Zone&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Zone zone:zoneList) &#123;<br>        <span class="hljs-keyword">if</span> (zone.parentId.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>            result.add(zone);<br>            setChildren(zoneList, zone);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setChildren</span><span class="hljs-params">(List&lt;Zone&gt; list, Zone parent)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (Zone zone: list) &#123;<br>        <span class="hljs-keyword">if</span>(parent.id.equals(zone.parentId))&#123;<br>            parent.children.add(zone);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (parent.children.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Zone zone: parent.children) &#123;<br>        setChildren(list, zone);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h1 id="第二种方法：两层循环"><a href="#第二种方法：两层循环" class="headerlink" title="第二种方法：两层循环"></a>第二种方法：两层循环</h1><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Zone&gt; <span class="hljs-title">buildTree2</span><span class="hljs-params">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    List&lt;Zone&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (Zone zone : zoneList) &#123;<br>        <span class="hljs-keyword">if</span> (zone.parentId.equals(<span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>            result.add(zone);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Zone child : zoneList) &#123;<br>            <span class="hljs-keyword">if</span> (child.parentId.equals(zone.id)) &#123;<br>                zone.addChildren(child);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三种方法：两次遍历"><a href="#第三种方法：两次遍历" class="headerlink" title="第三种方法：两次遍历"></a>第三种方法：两次遍历</h1><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Zone&gt; <span class="hljs-title">buildTree3</span><span class="hljs-params">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    Map&lt;String, List&lt;Zone&gt;&gt; zoneByParentIdMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    zoneList.forEach(zone -&gt; &#123;<br>        List&lt;Zone&gt; children = zoneByParentIdMap.getOrDefault(zone.parentId, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        children.add(zone);<br>        zoneByParentIdMap.put(zone.parentId, children);<br>    &#125;);<br>    zoneList.forEach(zone-&gt;zone.children = zoneByParentIdMap.get(zone.id));<br>    <span class="hljs-keyword">return</span> zoneList.stream()<br>            .filter(v -&gt; v.parentId.equals(<span class="hljs-string">&quot;0&quot;</span>))<br>            .collect(Collectors.toList());<br>&#125;<br></code></pre></div></td></tr></table></figure><p>用java8的stream，三行代码实现，Zone里面需要配合增加一个getParentId方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Zone&gt; <span class="hljs-title">buildTree3</span><span class="hljs-params">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    Map&lt;String, List&lt;Zone&gt;&gt; zoneByParentIdMap = zoneList.stream().collect(Collectors.groupingBy(Zone::getParentId));<br>    zoneList.forEach(zone-&gt;zone.children = zoneByParentIdMap.get(zone.id));<br>    <span class="hljs-keyword">return</span> zoneList.stream().filter(v -&gt; v.parentId.equals(<span class="hljs-string">&quot;0&quot;</span>)).collect(Collectors.toList());<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h1 id="三种方法对比"><a href="#三种方法对比" class="headerlink" title="三种方法对比"></a>三种方法对比</h1><p>前两种方法的时间复杂度都和叶子节点的个数相关，我们假设叶子节点个数为m<br><strong>方法一:</strong> 用递归的方法，时间复杂度等于：O(n +（n-m）* n)，根据<strong>初始算法</strong>那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n<sup>2</sup>)<br><strong>方法二:</strong> 用两层嵌套循环的方法，时间复杂度等于：O(n +（n-m）* n)，和方法一的时间复杂度是一样的，最终时间复杂度是O(n<sup>2</sup>)<br><strong>方法三:</strong> 用两次遍历的方法，时间复杂度等于：O(3n)，根据<strong>初始算法</strong>那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n)，但它的空间复杂度比前两种方法稍微大了一点，但是也是线性阶的，所以影响不是特别大。所以第三种方法是个人觉得比较优的一种方法</p><table><thead><tr><th>-</th><th>代码执行次数</th><th>时间复杂度</th><th>代码简洁程度</th></tr></thead><tbody><tr><td>方法1</td><td>O(n +（n-m）* n)</td><td>指性阶,O(n<sup>2</sup>)</td><td>一般</td></tr><tr><td>方法2</td><td>O(n +（n-m）* n)</td><td>指性阶,O(n<sup>2</sup>)</td><td>良好</td></tr><tr><td>方法3</td><td>O(3n)</td><td>线性阶,O(n</td><td>复杂</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法（一）：初识算法</title>
    <link href="/2020/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h2><blockquote><p>“算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”<br>——摘录来自: 程杰. “大话数据结构。”</p></blockquote><span id="more"></span><p>我个人理解，算法就是解决某一类问题的方法。我们的前辈总结了非常多优秀的算法，比如用于排序的冒泡排序、选择排序、插入排序算法，用于查找的二分查找、散列查找、顺序查找算法等。</p><h2 id="为什么要学习算法？"><a href="#为什么要学习算法？" class="headerlink" title="为什么要学习算法？"></a>为什么要学习算法？</h2><ol><li>算法是编程的基础，不管学习什么语言，算法早晚要学的，它是我们进阶到高级开发工程师所必须要掌握的知识之一。</li><li>可以培养自己写出高效的代码</li><li>锻炼自己的逻辑思维能力</li><li>~~ 面试，找工作。~~🤦‍♂️</li></ol><h2 id="举一个简单的算法例子"><a href="#举一个简单的算法例子" class="headerlink" title="举一个简单的算法例子"></a>举一个简单的算法例子</h2><p>大多数人都应该听说过著名数学家高斯的一个小故事：高斯在上小学的时候，老师布置了一个数学任务，让同学们对自然数从1到100求和。他很快就得出结果：5050。他的解释是这样的：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache">    <span class="hljs-attribute">num</span> = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + ... + <span class="hljs-number">99</span> + <span class="hljs-number">100</span>;<br>    <span class="hljs-attribute">num</span> = <span class="hljs-number">100</span> + <span class="hljs-number">99</span> + ... + <span class="hljs-number">3</span> + <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><span class="hljs-attribute">2</span> * num = <span class="hljs-number">101</span> + <span class="hljs-number">101</span> +... + <span class="hljs-number">101</span> + <span class="hljs-number">101</span>; // 一共<span class="hljs-number">100</span>个<span class="hljs-number">101</span>相加<br>    <span class="hljs-attribute">num</span> = <span class="hljs-number">101</span> * <span class="hljs-number">100</span> / <span class="hljs-number">2</span> = <span class="hljs-number">5050</span>；<br></code></pre></div></td></tr></table></figure><p>这道题如果用代码来实现的话，有两种解法：</p><ol><li><strong>普通解法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">computeSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        sum += i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li><strong>高斯的解法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">computeSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum =  (<span class="hljs-number">1</span> + n) * n / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>即使我们没有学过算法，我们也能看出来，这两种计算方法，第二种显然更加的高效，但是如果让我们来评价第二种算法有多高效，它的<strong>时间复杂度</strong>是多少，<strong>空间复杂度</strong>是多少，可能就需要我们了解一些算法的度量方法之后，才能准确的表达出来。</p><hr><p>下面我们从算法的定义，特性，要求，度量方法来完整的了解一下算法</p><h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><blockquote><p>“<strong>算法是描述解决问题的方法。</strong>算法（Algorithm）这个单词最早出现在波斯数学家阿勒·花刺子密在公元825年（相当于我们中国的唐朝时期）所写的《印度数字算术》中。如今普遍认可的对算法的定义是：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”</p></blockquote><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><p>算法有五个基本特性：输入、输出、有穷性，确定性和可行性。</p><ol><li><strong>输入：</strong>待解决问题的条件，一般来说，一个算法会有一个或多个输入参数。（也可以是零个输入参数，如：打印hello world）</li><li><strong>输出：</strong> 待解决问题的结果，输出的形式可能是打印控制台，或者返回一个数据。一个算法一定至少有一个输出。</li><li><strong>有穷性：</strong> 指的是解决问题的步骤，必须是有限的。从我们写代码角度来理解的话，就是不能出现死循环。这个有限的步骤，也是有一定边界的，如果我们写了一个算法，需要一百年才能计算出结果，虽然说步骤可能是有限的，但是就算一百年不断电，一百年之后谁能验证这个结果是否正确呢😂，所以说这个“有限”，一定要合理。</li><li><strong>确定性：</strong>相同的输入只能有唯一的结果，算法的每一步骤的意义都被精确定义而无歧义；</li><li><strong>可行性：</strong>算法必须可以被实现。也就是说它每一步都必须可以转换为程序上机运行，并且得到正确结果。</li></ol><h2 id="算法的要求"><a href="#算法的要求" class="headerlink" title="算法的要求"></a>算法的要求</h2><p>评价一个算法是否有效，是不是够好，有四个指标：正确性、可读性、健壮性、时间效率高和存储量低.</p><ol><li><strong>正确性</strong>：这是一个算法最基本的条件，它指的是，算法至少应该根据问题的描述和输入，得到一个正确的输出。</li><li><strong>可读性</strong>：算法设计的另一目的是为了便于阅读、理解和交流。（个人理解，这个指标的优先级在其他三个指标之后）</li><li><strong>健壮性</strong>：当输入不合法的参数，我们要保证我们的算法可以正常执行，并返回结果，而不是直接程序报错。</li><li><strong>时间效率高和存储量低</strong>： 这是评估一个算法是不是好的算法的指标，指的是这个算法执行的时间是不是足够短，消耗的内存是不是足够小。</li></ol><p>总的来说，一个有效算法必须满足正确性和健壮性，如果同时能满足时间效率高和存储量低以及可读性，那么它就是一个有效的，并且是一个优秀的算法。</p><h2 id="算法的度量方法"><a href="#算法的度量方法" class="headerlink" title="算法的度量方法"></a>算法的度量方法</h2><p>算法的度量方法有两种：1. 事后统计法；2. 事前估算法</p><h3 id="事后统计法"><a href="#事后统计法" class="headerlink" title="事后统计法"></a>事后统计法</h3><p>事前统计法，主要是通过一批固定的测试数据，让不同算法的程序去执行，得到结果后，统计出不同算法的结果进行统计分析来判断不同算法的效率高低。<br>虽然这样也可以计算出算法的效率高低。但是它的缺点也很明显：</p><ul><li>硬件要求完全一致；</li><li>测试数据设计困难，测试数据必须考虑的足够全面；</li><li>如果算法比较复杂，这个统计的时间可能会需要很久；</li></ul><p>所以一般来说，我们一般不考虑用这种方法来度量算法</p><h3 id="事前估算法"><a href="#事前估算法" class="headerlink" title="事前估算法"></a>事前估算法</h3><p>先来看一下影响程序执行效率的因素：1.硬件；2.编译器；3.程序指令的执行次数；4.问题的条件和输入；<br>通过分析我们发现，第1，2，4个因素都是算法无法影响的，所以我们只关注程序代码，那么我们再回到上面那道题，计算1-100的和，我们看一下两种算法的程序代码</p><ol><li><strong>普通解法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">computeSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">//执行1次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123; <span class="hljs-comment">//int i = 1执行1次，i &lt; n 执行 n 次，i++ 执行 n 次</span><br>        sum += i; <span class="hljs-comment">//执行n次</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>整个程序代码一共执行了 1+1+n+n+n+n=4n+2次<br>2. <strong>高斯的解法</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">computeSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum =  (<span class="hljs-number">1</span> + n) * n / <span class="hljs-number">2</span>; <span class="hljs-comment">// 执行1次</span><br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>整个程序代码一共执行了 1次</p><p><strong>所以，显而易见，1 &lt; 4n+2,第二种算法执行效率更高</strong>，第一种的时间复杂度，我们记作O(n),表示线性阶，第二种时间复杂度，我们计作O(1)，表示常数阶；</p><h2 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h2><blockquote><p>“在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。<br>这样用大写O( )来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。”<br>——摘录来自: 程杰. “大话数据结构。” </p></blockquote><p>简单理解，算法的时间复杂度和语句执行的次数紧密相关，如上面的提到的普通解法的算法执行次数:4n+2,我们用O(n)表示这个算法的时间复杂度。为什么不是O(4n+2)，或者O(4n)? 接着看下面的推导大O阶的方法：</p><blockquote><p>1．用常数1取代运行时间中的所有加法常数。<br>2．在修改后的运行次数函数中，只保留最高阶项。<br>3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。取最高阶的项并忽略其常系数<br>——摘录来自: 程杰. “大话数据结构。” </p></blockquote><p>接下来说为什么上面那个算法的执行次数是4n+2，但它的时间复杂度是O(n),<br>根据推导大O的方法1，可以得到 4n + 2 = O(4n + 1)；<br>根据推导大O的方法2，只保留最高阶，4n + 2 =O(4n);<br>根据推导大O的方法3，最高阶项是4n，那么4n相乘的常熟是4，就需要除以4，最终结果是 4n + 2 = O(4n / 4) = O(n);</p><p>下面是常见的时间复杂度及例子</p><table><thead><tr><th>函数阶</th><th>非正式术语</th><th>执行次数的例子</th></tr></thead><tbody><tr><td>O(1)</td><td>常数阶</td><td>1,2,12</td></tr><tr><td>O(n)</td><td>线性阶</td><td>4n+2,2n+1,n+10</td></tr><tr><td>O(n<sup>2</sup>)</td><td>平方阶</td><td>3n2+2n+1</td></tr><tr><td>O(logn)</td><td>对数阶</td><td>5log2n+20</td></tr><tr><td>O(nlogn)</td><td>nlogn阶</td><td>2n+3nlog2n+19</td></tr><tr><td>O(n<sup>3</sup>)</td><td>立方阶</td><td>6n<sup>3</sup>+2n+3n+4</td></tr><tr><td>O(2<sup>n</sup>)</td><td>指数阶</td><td>2<sup>n</sup></td></tr><tr><td>O(n!)</td><td>–</td><td>无</td></tr><tr><td>O(n<sup>n</sup>)</td><td>–</td><td>无</td></tr></tbody></table><p>最后两种时间复杂度很少用到，常用的时间复杂度所耗费的时间从小到大依次是：<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><blockquote><p>“一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)”<br>——摘录来自: 程杰. “大话数据结构。” </p></blockquote><p>空间复杂度一般我们也用大O来表示，问题的输入、条件、输出变量取决于问题，所以不算做算法本身的存储空间，算法的存储空间只和其他的辅助变量有关。只要辅助变量的数量是常数，也就是说空间复杂度为O(1),那么这个算法就可以称为<strong>原地工作</strong>，原地工作这个词在leetcode题目中可能会出现。</p><p>对于算法的空间复杂度一般来说讲的比较少，计算机内存越来越大了，只要不是特别离谱，我们一般情况下，可能会故意通过空间来换时间，像系统设计中的缓存，就是很好的例子，所以空间复杂度我们大概了解就行，不过多在介绍了。</p><h2 id="一张脑图概括"><a href="#一张脑图概括" class="headerlink" title="一张脑图概括"></a>一张脑图概括</h2><p>好了最后我们用一张图来总结一下这篇文章的内容</p><p>。。。<br>。。。<br>图片加载失败……<br><del>我只是困了想睡觉了🤦‍♂️</del></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
