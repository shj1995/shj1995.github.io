{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/banner1.jpg","path":"img/banner1.jpg","modified":0,"renderable":0},{"_id":"source/img/banner3.jpg","path":"img/banner3.jpg","modified":0,"renderable":0},{"_id":"source/img/banner2.jpeg","path":"img/banner2.jpeg","modified":0,"renderable":0},{"_id":"source/img/default.jpg","path":"img/default.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"40807a10c956b36d3291cfbeeae967ccf0a24243","modified":1624948023503},{"_id":"source/about/index.md","hash":"6dad4924ac78daf639a01dbeeb5cf058a5b37d69","modified":1624948023506},{"_id":"source/img/banner3.jpg","hash":"e3eb652463615ca9b5a276b8fdc268f713e9047b","modified":1624948023513},{"_id":"source/_posts/java/java中把一个list转tree的三种方法.md","hash":"1598600d84603ded7d9f035d1fc0b75fbb5a75fd","modified":1624948023504},{"_id":"source/_posts/java/如何保证I++的原子性.md","hash":"350b1b0f996326a6441379ba213ea904083f3feb","modified":1624953163263},{"_id":"source/_posts/数据结构与算法/数据结构与算法（一）：初识算法.md","hash":"1d5d909954114e4a668eba6ef90d1083391bcb49","modified":1624948023505},{"_id":"source/img/banner2.jpeg","hash":"72a96c6baf1c6a198a3fba74b478c4c254de9a5b","modified":1624948023511},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"523b9db3801ca892124502c17d72864457cc4b21","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"dac9d10d95b9e179e8cd7c439300b450db51f0c2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"a7c87a83becf7080bddd14e81a6f09ce8c3df109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"a49dc16f4413f6cdbf0b7bc5dfd4b89dafb382e8","modified":1624949712068},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6cbd88a2ef9dd2198d72ccc1899c4966ac5f49f9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"a154785aef120988d29409847977f24069d3a3d5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"9d6ff8772bf54d7458ae4e846e5a2d1f2921b8a7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"19c6db0ccebc8f59fa4ef9567a066b33223eccd6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"64d521c9c5b61d3a4852c74894fb574082dc7009","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"8723aa57f61134a2c1dc84cc7ea88ea366f4fda3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"cdcb607f1104543a42beda647f3c9cf0f3d11623","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"6ec30a9dd56341590af07f4227324f619025c109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"39e63b3e1502803c9e8ea0c44ea662a7bbe15744","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"248ecd01aead6e07ac1904a7b7c45395a922bcc7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"245f49aad0e4124b52aa82d981281ad9c871f1f8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"3e0fa1731b6e54dbcf52ccf8e200e83dc4549bfa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"b3d93135d9ae74f006da31ec54343308bbd77cb5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"606131cb807846bf43776a9073fcc1473d359ec9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"725a1fe23c672fca87edc57739b748c3adf705da","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"fb4502fc9204284f8b4e8dabde8477d478e826e5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"ffe08e76c9ebd4fc27715b8a60f385b3f10d0348","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"9238063c5e2928bb6fce2b99cd25ad85e78c4d1c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"5b61661fbc65752f54f99402077dbb03044149a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ab71df2e56b60e8e193ff827e81704e5b358a977","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"a2d08e3b9f98b6371b2e64d664f079c99571494b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"26d29403d8ecb0b533e63bde3ca73b2c91f171ff","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"dabd87267d60240c0daea0f35a46f30ee1b2337a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4c6fffc6d4a3b8830931800ee7da99dccf1be36e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"ad7dcc8a060d94d3c44ca5e0788a24ca38be0f79","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"766fcf017deb4c8b0c260ac4c8d2e3489407ad89","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"35539a1ce8476e75515015a06d01ec66e4af6834","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/img/banner1.jpg","hash":"a31396e5519fdff648ebf8996a4bbca297280923","modified":1624948023510},{"_id":"public/local-search.xml","hash":"6da1c66994548a7f272d6767b5b015569438bf48","modified":1624954133711},{"_id":"public/about/index.html","hash":"1b14ab0af53adcfd3c8921e505b43a0f43589f5e","modified":1624954133711},{"_id":"public/archives/index.html","hash":"45ed42038ced5f8f559de2467ba26ca80e9ca0c8","modified":1624954133711},{"_id":"public/archives/2020/03/index.html","hash":"99918263e63d45b54265c8775cf46791f2200dfd","modified":1624954133711},{"_id":"public/archives/2020/index.html","hash":"45ed42038ced5f8f559de2467ba26ca80e9ca0c8","modified":1624954133711},{"_id":"public/index.html","hash":"d372a687fd5462ec6fcd005457808089db1865cf","modified":1624954133711},{"_id":"public/archives/2020/09/index.html","hash":"8e2fb97b4ae4968c24a32ab93bfc70a05212249d","modified":1624954133711},{"_id":"public/categories/数据结构与算法/index.html","hash":"3cbe2a0a2f5d9c38e6255646a703705fa94f238a","modified":1624954133711},{"_id":"public/404.html","hash":"732e36f57a9d7c4f888441a3a9c2224ca6c990d9","modified":1624954133711},{"_id":"public/tags/学习笔记/index.html","hash":"fa4bf0e468ebad53b2c0301a842eda50e28c0636","modified":1624954133711},{"_id":"public/tags/数据结构与算法/index.html","hash":"51d5f604862388e1d8e1a2446df48ce682f5ca3d","modified":1624954133711},{"_id":"public/tags/index.html","hash":"9f0d80c3089b9a5d8acb994b9e005dd143cb606f","modified":1624954133711},{"_id":"public/categories/index.html","hash":"1f9bdf88d2c238beed15779987afdab03b809cf0","modified":1624954133711},{"_id":"public/links/index.html","hash":"29b4f4460206db2abfecaf7ffc44c5a79eea6f87","modified":1624954133711},{"_id":"public/2020/09/19/java/如何保证I++的原子性/index.html","hash":"63d2e65fe97d400d07681945d15f6831c85c02c9","modified":1624954133711},{"_id":"public/2020/03/21/java/java中把一个list转tree的三种方法/index.html","hash":"3d90c1bd5769c536d4948914e2de10def70a9967","modified":1624954133711},{"_id":"public/2020/03/14/数据结构与算法/数据结构与算法（一）：初识算法/index.html","hash":"7ebcb221a19f2671255ad79d512b0dc2d276ee0e","modified":1624954133711},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1624954133711},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1624954133711},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1624954133711},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1624954133711},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1624954133711},{"_id":"public/CNAME","hash":"40807a10c956b36d3291cfbeeae967ccf0a24243","modified":1624954133711},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1624954133711},{"_id":"public/img/banner3.jpg","hash":"e3eb652463615ca9b5a276b8fdc268f713e9047b","modified":1624954133711},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1624954133711},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1624954133711},{"_id":"public/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":1624954133711},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1624954133711},{"_id":"public/css/main.css","hash":"be9a0652de06d61fa26f4b4128b29bcc5a4a0ad7","modified":1624954133711},{"_id":"public/img/banner2.jpeg","hash":"72a96c6baf1c6a198a3fba74b478c4c254de9a5b","modified":1624954133711},{"_id":"public/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":1624954133711},{"_id":"public/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":1624954133711},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1624954133711},{"_id":"public/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":1624954133711},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1624954133711},{"_id":"public/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":1624954133711},{"_id":"public/img/banner1.jpg","hash":"a31396e5519fdff648ebf8996a4bbca297280923","modified":1624954133711},{"_id":"source/img/default.jpg","hash":"e3eb652463615ca9b5a276b8fdc268f713e9047b","modified":1624948023548}],"Category":[{"name":"数据结构与算法","_id":"ckqhrqih00004t0uvbqqs84uz"}],"Data":[],"Page":[{"title":"about","date":"2020-02-23T11:20:33.000Z","layout":"about","_content":"这里写正文，支持 Markdown, HTML\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-02-23 19:20:33\nlayout: about\n---\n这里写正文，支持 Markdown, HTML\n","updated":"2021-06-29T06:27:03.506Z","path":"about/index.html","comments":1,"_id":"ckqhrqigp0000t0uvebo28ghz","content":"<p>这里写正文，支持 Markdown, HTML</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这里写正文，支持 Markdown, HTML</p>\n"}],"Post":[{"title":"java中把一个list转tree的三种方法","abbrlink":"bc773bb5","date":"2020-03-21T05:00:32.000Z","_content":"> i++是不是一个原子操作？\n相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，三个问题：1.什么是原子性操作，2，i++是不是原子操作，3，它为什么不是原子操作，4，如何保证i++的原子性\n<!-- more-->\n# 问题\n周二面试中，面试官提了一个问题，当时答得不是特别好，手写代码能力还是不行啊，一个是比较紧张，一个是代码没法调试，写递归的时候给自己绕晕了。下面是问题：\n> 我们有个需求，数据库要存一个无限级联的tree，比如菜单，或者地区等数据，现有两个问题，1.问如何设计表，2.怎么返回给前端一个无线级联的json数据；\n# 思考\n第一个问题，设计表的话，拿地区举例子,这个只要有id，parentId，就没啥问题。主要是第二个问题\n``` sql\ncreate table Zone {\n    id varchar(255)\n    name varchar(255)\n    code varchar(255)\n    parentId varchar(255)\n}\n```\n\n第二个问题，我的想法是通过一个sql查询查出来所有数据，得到一个 Zone集合，然后就回到了主题，如何用java把list转tree。我第一想法是递归。递归的话，需要考虑几个因素，1.终止条件；2.处理逻辑，3.参数（数据参数，当前层级），4.返回值，然后套入这个问题，分析如下：\n1. 中断条件：当前节点，无子节点，终止退出\n2. 处理逻辑：根据parentId查找节点，设置到parent的children属性中\n3. 参数：数据就是list集合，当前层级参数是parent节点\n4. 无\n\n---\n# 准备工作\n首先我们需要一些辅助类，代码如下（避免代码冗长，我就不写get，set方法了，理解意思就行，实际项目中肯定不能写么写）\n\n地区类：Zone.class\n``` java\n\nimport java.util.List;\n\npublic class Zone {\n    String id;\n    String name;\n    String parentId;\n    List<Test.Zone> children;\n\n    public Zone(String id, String name, String parentId) {\n        this.id = id;\n        this.name = name;\n        this.parentId = parentId;\n    }\n    public void addChildren(Zone zone){\n        if(children == null) {\n            children = new ArrayList<>();\n        }\n        children.add(zone);\n    }\n}\n\n```\n测试类：Test.java\n``` java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        List<Zone> zoneList = new ArrayList<>();\n        zoneList.add(new Zone(\"1\",\"上海\",\"0\"));\n        zoneList.add(new Zone(\"2\",\"北京\",\"0\"));\n        zoneList.add(new Zone(\"3\",\"河南\",\"0\"));\n        zoneList.add(new Zone(\"31\",\"郑州\",\"3\"));\n        zoneList.add(new Zone(\"32\",\"洛阳\",\"3\"));\n        zoneList.add(new Zone(\"321\",\"洛龙\",\"32\"));\n        zoneList.add(new Zone(\"11\",\"松江\",\"1\"));\n        zoneList.add(new Zone(\"111\",\"泗泾\",\"11\"));\n        List<Zone> rootZone1 = ZoneUtils.buildTree1(zoneList); // 测试第一种方法\n        List<Zone> rootZone2 = ZoneUtils.buildTree2(zoneList); // 测试第二种方法\n        List<Zone> rootZone3 = ZoneUtils.buildTree3(zoneList); // 测试第三种方法\n    }\n}\n```\n地区工具类，提供三种构建tree的方法：ZoneUtils.java\n``` java\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class ZoneUtils {\n    public static List<Zone> buildTree1(List<Zone> zoneList) {\n        // TODO : 第一种解法\n        return null;\n    }\n    public static List<Zone> buildTree2(List<Zone> zoneList) {\n        // TODO : 第二种解法\n        return null;\n    }\n    public static List<Zone> buildTree3(List<Zone> zoneList) {\n        // TODO : 第三种解法\n        return null;\n    }\n}\n\n```\n# 第一种方法：递归\n\n``` java\npublic static List<Zone> buildTree1(List<Zone> zoneList) {\n    List<Zone> result = new ArrayList<>();\n    for (Zone zone:zoneList) {\n        if (zone.parentId.equals(\"0\")) {\n            result.add(zone);\n            setChildren(zoneList, zone);\n        }\n    }\n    return result;\n}\n\npublic static void setChildren(List<Zone> list, Zone parent) {\n    for (Zone zone: list) {\n        if(parent.id.equals(zone.parentId)){\n            parent.children.add(zone);\n        }\n    }\n    if (parent.children.isEmpty()) {\n        return;\n    }\n    for (Zone zone: parent.children) {\n        setChildren(list, zone);\n    }\n}\n\n```\n# 第二种方法：两层循环\n``` java\npublic static List<Zone> buildTree2(List<Zone> zoneList) {\n    List<Zone> result = new ArrayList<>();\n    for (Zone zone : zoneList) {\n        if (zone.parentId.equals(\"0\")) {\n            result.add(zone);\n        }\n        for (Zone child : zoneList) {\n            if (child.parentId.equals(zone.id)) {\n                zone.addChildren(child);\n            }\n        }\n    }\n    return result;\n}\n```\n# 第三种方法：两次遍历\n``` java\npublic static List<Zone> buildTree3(List<Zone> zoneList) {\n    Map<String, List<Zone>> zoneByParentIdMap = new HashMap<>();\n    zoneList.forEach(zone -> {\n        List<Zone> children = zoneByParentIdMap.getOrDefault(zone.parentId, new ArrayList<>());\n        children.add(zone);\n        zoneByParentIdMap.put(zone.parentId, children);\n    });\n    zoneList.forEach(zone->zone.children = zoneByParentIdMap.get(zone.id));\n    return zoneList.stream()\n            .filter(v -> v.parentId.equals(\"0\"))\n            .collect(Collectors.toList());\n}\n```\n用java8的stream，三行代码实现，Zone里面需要配合增加一个getParentId方法\n``` java\npublic static List<Zone> buildTree3(List<Zone> zoneList) {\n    Map<String, List<Zone>> zoneByParentIdMap = zoneList.stream().collect(Collectors.groupingBy(Zone::getParentId));\n    zoneList.forEach(zone->zone.children = zoneByParentIdMap.get(zone.id));\n    return zoneList.stream().filter(v -> v.parentId.equals(\"0\")).collect(Collectors.toList());\n}\n\n```\n# 三种方法对比\n前两种方法的时间复杂度都和叶子节点的个数相关，我们假设叶子节点个数为m\n**方法一:** 用递归的方法，时间复杂度等于：O(n +（n-m）* n)，根据**初始算法**那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n<sup>2</sup>)\n**方法二:** 用两层嵌套循环的方法，时间复杂度等于：O(n +（n-m）* n)，和方法一的时间复杂度是一样的，最终时间复杂度是O(n<sup>2</sup>)\n**方法三:** 用两次遍历的方法，时间复杂度等于：O(3n)，根据**初始算法**那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n)，但它的空间复杂度比前两种方法稍微大了一点，但是也是线性阶的，所以影响不是特别大。所以第三种方法是个人觉得比较优的一种方法\n\n|-|代码执行次数|时间复杂度|代码简洁程度|\n|-|-|-|-|\n|方法1|O(n +（n-m）* n)|指性阶,O(n<sup>2</sup>) |一般|\n|方法2|O(n +（n-m）* n)|指性阶,O(n<sup>2</sup>) |良好|\n|方法3|O(3n)|线性阶,O(n|复杂|","source":"_posts/java/java中把一个list转tree的三种方法.md","raw":"---\ntitle: java中把一个list转tree的三种方法\nabbrlink: bc773bb5\ndate: 2020-03-21 13:00:32\ntags:\n---\n> i++是不是一个原子操作？\n相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，三个问题：1.什么是原子性操作，2，i++是不是原子操作，3，它为什么不是原子操作，4，如何保证i++的原子性\n<!-- more-->\n# 问题\n周二面试中，面试官提了一个问题，当时答得不是特别好，手写代码能力还是不行啊，一个是比较紧张，一个是代码没法调试，写递归的时候给自己绕晕了。下面是问题：\n> 我们有个需求，数据库要存一个无限级联的tree，比如菜单，或者地区等数据，现有两个问题，1.问如何设计表，2.怎么返回给前端一个无线级联的json数据；\n# 思考\n第一个问题，设计表的话，拿地区举例子,这个只要有id，parentId，就没啥问题。主要是第二个问题\n``` sql\ncreate table Zone {\n    id varchar(255)\n    name varchar(255)\n    code varchar(255)\n    parentId varchar(255)\n}\n```\n\n第二个问题，我的想法是通过一个sql查询查出来所有数据，得到一个 Zone集合，然后就回到了主题，如何用java把list转tree。我第一想法是递归。递归的话，需要考虑几个因素，1.终止条件；2.处理逻辑，3.参数（数据参数，当前层级），4.返回值，然后套入这个问题，分析如下：\n1. 中断条件：当前节点，无子节点，终止退出\n2. 处理逻辑：根据parentId查找节点，设置到parent的children属性中\n3. 参数：数据就是list集合，当前层级参数是parent节点\n4. 无\n\n---\n# 准备工作\n首先我们需要一些辅助类，代码如下（避免代码冗长，我就不写get，set方法了，理解意思就行，实际项目中肯定不能写么写）\n\n地区类：Zone.class\n``` java\n\nimport java.util.List;\n\npublic class Zone {\n    String id;\n    String name;\n    String parentId;\n    List<Test.Zone> children;\n\n    public Zone(String id, String name, String parentId) {\n        this.id = id;\n        this.name = name;\n        this.parentId = parentId;\n    }\n    public void addChildren(Zone zone){\n        if(children == null) {\n            children = new ArrayList<>();\n        }\n        children.add(zone);\n    }\n}\n\n```\n测试类：Test.java\n``` java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        List<Zone> zoneList = new ArrayList<>();\n        zoneList.add(new Zone(\"1\",\"上海\",\"0\"));\n        zoneList.add(new Zone(\"2\",\"北京\",\"0\"));\n        zoneList.add(new Zone(\"3\",\"河南\",\"0\"));\n        zoneList.add(new Zone(\"31\",\"郑州\",\"3\"));\n        zoneList.add(new Zone(\"32\",\"洛阳\",\"3\"));\n        zoneList.add(new Zone(\"321\",\"洛龙\",\"32\"));\n        zoneList.add(new Zone(\"11\",\"松江\",\"1\"));\n        zoneList.add(new Zone(\"111\",\"泗泾\",\"11\"));\n        List<Zone> rootZone1 = ZoneUtils.buildTree1(zoneList); // 测试第一种方法\n        List<Zone> rootZone2 = ZoneUtils.buildTree2(zoneList); // 测试第二种方法\n        List<Zone> rootZone3 = ZoneUtils.buildTree3(zoneList); // 测试第三种方法\n    }\n}\n```\n地区工具类，提供三种构建tree的方法：ZoneUtils.java\n``` java\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class ZoneUtils {\n    public static List<Zone> buildTree1(List<Zone> zoneList) {\n        // TODO : 第一种解法\n        return null;\n    }\n    public static List<Zone> buildTree2(List<Zone> zoneList) {\n        // TODO : 第二种解法\n        return null;\n    }\n    public static List<Zone> buildTree3(List<Zone> zoneList) {\n        // TODO : 第三种解法\n        return null;\n    }\n}\n\n```\n# 第一种方法：递归\n\n``` java\npublic static List<Zone> buildTree1(List<Zone> zoneList) {\n    List<Zone> result = new ArrayList<>();\n    for (Zone zone:zoneList) {\n        if (zone.parentId.equals(\"0\")) {\n            result.add(zone);\n            setChildren(zoneList, zone);\n        }\n    }\n    return result;\n}\n\npublic static void setChildren(List<Zone> list, Zone parent) {\n    for (Zone zone: list) {\n        if(parent.id.equals(zone.parentId)){\n            parent.children.add(zone);\n        }\n    }\n    if (parent.children.isEmpty()) {\n        return;\n    }\n    for (Zone zone: parent.children) {\n        setChildren(list, zone);\n    }\n}\n\n```\n# 第二种方法：两层循环\n``` java\npublic static List<Zone> buildTree2(List<Zone> zoneList) {\n    List<Zone> result = new ArrayList<>();\n    for (Zone zone : zoneList) {\n        if (zone.parentId.equals(\"0\")) {\n            result.add(zone);\n        }\n        for (Zone child : zoneList) {\n            if (child.parentId.equals(zone.id)) {\n                zone.addChildren(child);\n            }\n        }\n    }\n    return result;\n}\n```\n# 第三种方法：两次遍历\n``` java\npublic static List<Zone> buildTree3(List<Zone> zoneList) {\n    Map<String, List<Zone>> zoneByParentIdMap = new HashMap<>();\n    zoneList.forEach(zone -> {\n        List<Zone> children = zoneByParentIdMap.getOrDefault(zone.parentId, new ArrayList<>());\n        children.add(zone);\n        zoneByParentIdMap.put(zone.parentId, children);\n    });\n    zoneList.forEach(zone->zone.children = zoneByParentIdMap.get(zone.id));\n    return zoneList.stream()\n            .filter(v -> v.parentId.equals(\"0\"))\n            .collect(Collectors.toList());\n}\n```\n用java8的stream，三行代码实现，Zone里面需要配合增加一个getParentId方法\n``` java\npublic static List<Zone> buildTree3(List<Zone> zoneList) {\n    Map<String, List<Zone>> zoneByParentIdMap = zoneList.stream().collect(Collectors.groupingBy(Zone::getParentId));\n    zoneList.forEach(zone->zone.children = zoneByParentIdMap.get(zone.id));\n    return zoneList.stream().filter(v -> v.parentId.equals(\"0\")).collect(Collectors.toList());\n}\n\n```\n# 三种方法对比\n前两种方法的时间复杂度都和叶子节点的个数相关，我们假设叶子节点个数为m\n**方法一:** 用递归的方法，时间复杂度等于：O(n +（n-m）* n)，根据**初始算法**那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n<sup>2</sup>)\n**方法二:** 用两层嵌套循环的方法，时间复杂度等于：O(n +（n-m）* n)，和方法一的时间复杂度是一样的，最终时间复杂度是O(n<sup>2</sup>)\n**方法三:** 用两次遍历的方法，时间复杂度等于：O(3n)，根据**初始算法**那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n)，但它的空间复杂度比前两种方法稍微大了一点，但是也是线性阶的，所以影响不是特别大。所以第三种方法是个人觉得比较优的一种方法\n\n|-|代码执行次数|时间复杂度|代码简洁程度|\n|-|-|-|-|\n|方法1|O(n +（n-m）* n)|指性阶,O(n<sup>2</sup>) |一般|\n|方法2|O(n +（n-m）* n)|指性阶,O(n<sup>2</sup>) |良好|\n|方法3|O(3n)|线性阶,O(n|复杂|","slug":"java/java中把一个list转tree的三种方法","published":1,"updated":"2021-06-29T06:27:03.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqhrqigs0001t0uvbeqte6tb","content":"<blockquote>\n<p>i++是不是一个原子操作？<br>相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，三个问题：1.什么是原子性操作，2，i++是不是原子操作，3，它为什么不是原子操作，4，如何保证i++的原子性</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>周二面试中，面试官提了一个问题，当时答得不是特别好，手写代码能力还是不行啊，一个是比较紧张，一个是代码没法调试，写递归的时候给自己绕晕了。下面是问题：</p>\n<blockquote>\n<p>我们有个需求，数据库要存一个无限级联的tree，比如菜单，或者地区等数据，现有两个问题，1.问如何设计表，2.怎么返回给前端一个无线级联的json数据；</p>\n</blockquote>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><p>第一个问题，设计表的话，拿地区举例子,这个只要有id，parentId，就没啥问题。主要是第二个问题</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> Zone &#123;<br>    id <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>)<br>    name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>)<br>    code <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>)<br>    parentId <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>第二个问题，我的想法是通过一个sql查询查出来所有数据，得到一个 Zone集合，然后就回到了主题，如何用java把list转tree。我第一想法是递归。递归的话，需要考虑几个因素，1.终止条件；2.处理逻辑，3.参数（数据参数，当前层级），4.返回值，然后套入这个问题，分析如下：</p>\n<ol>\n<li>中断条件：当前节点，无子节点，终止退出</li>\n<li>处理逻辑：根据parentId查找节点，设置到parent的children属性中</li>\n<li>参数：数据就是list集合，当前层级参数是parent节点</li>\n<li>无</li>\n</ol>\n<hr>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>首先我们需要一些辅助类，代码如下（避免代码冗长，我就不写get，set方法了，理解意思就行，实际项目中肯定不能写么写）</p>\n<p>地区类：Zone.class</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><br><span class=\"hljs-keyword\">import</span> java.util.List;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Zone</span> </span>&#123;<br>    String id;<br>    String name;<br>    String parentId;<br>    List&lt;Test.Zone&gt; children;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Zone</span><span class=\"hljs-params\">(String id, String name, String parentId)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.id = id;<br>        <span class=\"hljs-keyword\">this</span>.name = name;<br>        <span class=\"hljs-keyword\">this</span>.parentId = parentId;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addChildren</span><span class=\"hljs-params\">(Zone zone)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(children == <span class=\"hljs-keyword\">null</span>) &#123;<br>            children = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        &#125;<br>        children.add(zone);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>\n<p>测试类：Test.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.ArrayList;<br><span class=\"hljs-keyword\">import</span> java.util.List;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        List&lt;Zone&gt; zoneList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;1&quot;</span>,<span class=\"hljs-string\">&quot;上海&quot;</span>,<span class=\"hljs-string\">&quot;0&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;2&quot;</span>,<span class=\"hljs-string\">&quot;北京&quot;</span>,<span class=\"hljs-string\">&quot;0&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;3&quot;</span>,<span class=\"hljs-string\">&quot;河南&quot;</span>,<span class=\"hljs-string\">&quot;0&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;31&quot;</span>,<span class=\"hljs-string\">&quot;郑州&quot;</span>,<span class=\"hljs-string\">&quot;3&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;32&quot;</span>,<span class=\"hljs-string\">&quot;洛阳&quot;</span>,<span class=\"hljs-string\">&quot;3&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;321&quot;</span>,<span class=\"hljs-string\">&quot;洛龙&quot;</span>,<span class=\"hljs-string\">&quot;32&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;11&quot;</span>,<span class=\"hljs-string\">&quot;松江&quot;</span>,<span class=\"hljs-string\">&quot;1&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;111&quot;</span>,<span class=\"hljs-string\">&quot;泗泾&quot;</span>,<span class=\"hljs-string\">&quot;11&quot;</span>));<br>        List&lt;Zone&gt; rootZone1 = ZoneUtils.buildTree1(zoneList); <span class=\"hljs-comment\">// 测试第一种方法</span><br>        List&lt;Zone&gt; rootZone2 = ZoneUtils.buildTree2(zoneList); <span class=\"hljs-comment\">// 测试第二种方法</span><br>        List&lt;Zone&gt; rootZone3 = ZoneUtils.buildTree3(zoneList); <span class=\"hljs-comment\">// 测试第三种方法</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<p>地区工具类，提供三种构建tree的方法：ZoneUtils.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><br><span class=\"hljs-keyword\">import</span> java.util.ArrayList;<br><span class=\"hljs-keyword\">import</span> java.util.HashMap;<br><span class=\"hljs-keyword\">import</span> java.util.List;<br><span class=\"hljs-keyword\">import</span> java.util.Map;<br><span class=\"hljs-keyword\">import</span> java.util.stream.Collectors;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ZoneUtils</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree1</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO : 第一种解法</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree2</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO : 第二种解法</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree3</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO : 第三种解法</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>\n<h1 id=\"第一种方法：递归\"><a href=\"#第一种方法：递归\" class=\"headerlink\" title=\"第一种方法：递归\"></a>第一种方法：递归</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree1</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    List&lt;Zone&gt; result = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span> (Zone zone:zoneList) &#123;<br>        <span class=\"hljs-keyword\">if</span> (zone.parentId.equals(<span class=\"hljs-string\">&quot;0&quot;</span>)) &#123;<br>            result.add(zone);<br>            setChildren(zoneList, zone);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setChildren</span><span class=\"hljs-params\">(List&lt;Zone&gt; list, Zone parent)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (Zone zone: list) &#123;<br>        <span class=\"hljs-keyword\">if</span>(parent.id.equals(zone.parentId))&#123;<br>            parent.children.add(zone);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (parent.children.isEmpty()) &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (Zone zone: parent.children) &#123;<br>        setChildren(list, zone);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>\n<h1 id=\"第二种方法：两层循环\"><a href=\"#第二种方法：两层循环\" class=\"headerlink\" title=\"第二种方法：两层循环\"></a>第二种方法：两层循环</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree2</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    List&lt;Zone&gt; result = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span> (Zone zone : zoneList) &#123;<br>        <span class=\"hljs-keyword\">if</span> (zone.parentId.equals(<span class=\"hljs-string\">&quot;0&quot;</span>)) &#123;<br>            result.add(zone);<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (Zone child : zoneList) &#123;<br>            <span class=\"hljs-keyword\">if</span> (child.parentId.equals(zone.id)) &#123;<br>                zone.addChildren(child);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<h1 id=\"第三种方法：两次遍历\"><a href=\"#第三种方法：两次遍历\" class=\"headerlink\" title=\"第三种方法：两次遍历\"></a>第三种方法：两次遍历</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree3</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    Map&lt;String, List&lt;Zone&gt;&gt; zoneByParentIdMap = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();<br>    zoneList.forEach(zone -&gt; &#123;<br>        List&lt;Zone&gt; children = zoneByParentIdMap.getOrDefault(zone.parentId, <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;());<br>        children.add(zone);<br>        zoneByParentIdMap.put(zone.parentId, children);<br>    &#125;);<br>    zoneList.forEach(zone-&gt;zone.children = zoneByParentIdMap.get(zone.id));<br>    <span class=\"hljs-keyword\">return</span> zoneList.stream()<br>            .filter(v -&gt; v.parentId.equals(<span class=\"hljs-string\">&quot;0&quot;</span>))<br>            .collect(Collectors.toList());<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<p>用java8的stream，三行代码实现，Zone里面需要配合增加一个getParentId方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree3</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    Map&lt;String, List&lt;Zone&gt;&gt; zoneByParentIdMap = zoneList.stream().collect(Collectors.groupingBy(Zone::getParentId));<br>    zoneList.forEach(zone-&gt;zone.children = zoneByParentIdMap.get(zone.id));<br>    <span class=\"hljs-keyword\">return</span> zoneList.stream().filter(v -&gt; v.parentId.equals(<span class=\"hljs-string\">&quot;0&quot;</span>)).collect(Collectors.toList());<br>&#125;<br><br></code></pre></div></td></tr></table></figure>\n<h1 id=\"三种方法对比\"><a href=\"#三种方法对比\" class=\"headerlink\" title=\"三种方法对比\"></a>三种方法对比</h1><p>前两种方法的时间复杂度都和叶子节点的个数相关，我们假设叶子节点个数为m<br><strong>方法一:</strong> 用递归的方法，时间复杂度等于：O(n +（n-m）* n)，根据<strong>初始算法</strong>那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n<sup>2</sup>)<br><strong>方法二:</strong> 用两层嵌套循环的方法，时间复杂度等于：O(n +（n-m）* n)，和方法一的时间复杂度是一样的，最终时间复杂度是O(n<sup>2</sup>)<br><strong>方法三:</strong> 用两次遍历的方法，时间复杂度等于：O(3n)，根据<strong>初始算法</strong>那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n)，但它的空间复杂度比前两种方法稍微大了一点，但是也是线性阶的，所以影响不是特别大。所以第三种方法是个人觉得比较优的一种方法</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>代码执行次数</th>\n<th>时间复杂度</th>\n<th>代码简洁程度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>方法1</td>\n<td>O(n +（n-m）* n)</td>\n<td>指性阶,O(n<sup>2</sup>)</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>方法2</td>\n<td>O(n +（n-m）* n)</td>\n<td>指性阶,O(n<sup>2</sup>)</td>\n<td>良好</td>\n</tr>\n<tr>\n<td>方法3</td>\n<td>O(3n)</td>\n<td>线性阶,O(n</td>\n<td>复杂</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>i++是不是一个原子操作？<br>相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，三个问题：1.什么是原子性操作，2，i++是不是原子操作，3，它为什么不是原子操作，4，如何保证i++的原子性</p>\n</blockquote>","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>周二面试中，面试官提了一个问题，当时答得不是特别好，手写代码能力还是不行啊，一个是比较紧张，一个是代码没法调试，写递归的时候给自己绕晕了。下面是问题：</p>\n<blockquote>\n<p>我们有个需求，数据库要存一个无限级联的tree，比如菜单，或者地区等数据，现有两个问题，1.问如何设计表，2.怎么返回给前端一个无线级联的json数据；</p>\n</blockquote>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><p>第一个问题，设计表的话，拿地区举例子,这个只要有id，parentId，就没啥问题。主要是第二个问题</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> Zone &#123;<br>    id <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>)<br>    name <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>)<br>    code <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>)<br>    parentId <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>第二个问题，我的想法是通过一个sql查询查出来所有数据，得到一个 Zone集合，然后就回到了主题，如何用java把list转tree。我第一想法是递归。递归的话，需要考虑几个因素，1.终止条件；2.处理逻辑，3.参数（数据参数，当前层级），4.返回值，然后套入这个问题，分析如下：</p>\n<ol>\n<li>中断条件：当前节点，无子节点，终止退出</li>\n<li>处理逻辑：根据parentId查找节点，设置到parent的children属性中</li>\n<li>参数：数据就是list集合，当前层级参数是parent节点</li>\n<li>无</li>\n</ol>\n<hr>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>首先我们需要一些辅助类，代码如下（避免代码冗长，我就不写get，set方法了，理解意思就行，实际项目中肯定不能写么写）</p>\n<p>地区类：Zone.class</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-keyword\">import</span> java.util.List;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Zone</span> </span>&#123;<br>    String id;<br>    String name;<br>    String parentId;<br>    List&lt;Test.Zone&gt; children;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Zone</span><span class=\"hljs-params\">(String id, String name, String parentId)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.id = id;<br>        <span class=\"hljs-keyword\">this</span>.name = name;<br>        <span class=\"hljs-keyword\">this</span>.parentId = parentId;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addChildren</span><span class=\"hljs-params\">(Zone zone)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(children == <span class=\"hljs-keyword\">null</span>) &#123;<br>            children = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        &#125;<br>        children.add(zone);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<p>测试类：Test.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.ArrayList;<br><span class=\"hljs-keyword\">import</span> java.util.List;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        List&lt;Zone&gt; zoneList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;1&quot;</span>,<span class=\"hljs-string\">&quot;上海&quot;</span>,<span class=\"hljs-string\">&quot;0&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;2&quot;</span>,<span class=\"hljs-string\">&quot;北京&quot;</span>,<span class=\"hljs-string\">&quot;0&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;3&quot;</span>,<span class=\"hljs-string\">&quot;河南&quot;</span>,<span class=\"hljs-string\">&quot;0&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;31&quot;</span>,<span class=\"hljs-string\">&quot;郑州&quot;</span>,<span class=\"hljs-string\">&quot;3&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;32&quot;</span>,<span class=\"hljs-string\">&quot;洛阳&quot;</span>,<span class=\"hljs-string\">&quot;3&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;321&quot;</span>,<span class=\"hljs-string\">&quot;洛龙&quot;</span>,<span class=\"hljs-string\">&quot;32&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;11&quot;</span>,<span class=\"hljs-string\">&quot;松江&quot;</span>,<span class=\"hljs-string\">&quot;1&quot;</span>));<br>        zoneList.add(<span class=\"hljs-keyword\">new</span> Zone(<span class=\"hljs-string\">&quot;111&quot;</span>,<span class=\"hljs-string\">&quot;泗泾&quot;</span>,<span class=\"hljs-string\">&quot;11&quot;</span>));<br>        List&lt;Zone&gt; rootZone1 = ZoneUtils.buildTree1(zoneList); <span class=\"hljs-comment\">// 测试第一种方法</span><br>        List&lt;Zone&gt; rootZone2 = ZoneUtils.buildTree2(zoneList); <span class=\"hljs-comment\">// 测试第二种方法</span><br>        List&lt;Zone&gt; rootZone3 = ZoneUtils.buildTree3(zoneList); <span class=\"hljs-comment\">// 测试第三种方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>地区工具类，提供三种构建tree的方法：ZoneUtils.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><br><span class=\"hljs-keyword\">import</span> java.util.ArrayList;<br><span class=\"hljs-keyword\">import</span> java.util.HashMap;<br><span class=\"hljs-keyword\">import</span> java.util.List;<br><span class=\"hljs-keyword\">import</span> java.util.Map;<br><span class=\"hljs-keyword\">import</span> java.util.stream.Collectors;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ZoneUtils</span> </span>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree1</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO : 第一种解法</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree2</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO : 第二种解法</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree3</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// TODO : 第三种解法</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h1 id=\"第一种方法：递归\"><a href=\"#第一种方法：递归\" class=\"headerlink\" title=\"第一种方法：递归\"></a>第一种方法：递归</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree1</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    List&lt;Zone&gt; result = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span> (Zone zone:zoneList) &#123;<br>        <span class=\"hljs-keyword\">if</span> (zone.parentId.equals(<span class=\"hljs-string\">&quot;0&quot;</span>)) &#123;<br>            result.add(zone);<br>            setChildren(zoneList, zone);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setChildren</span><span class=\"hljs-params\">(List&lt;Zone&gt; list, Zone parent)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (Zone zone: list) &#123;<br>        <span class=\"hljs-keyword\">if</span>(parent.id.equals(zone.parentId))&#123;<br>            parent.children.add(zone);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (parent.children.isEmpty()) &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (Zone zone: parent.children) &#123;<br>        setChildren(list, zone);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h1 id=\"第二种方法：两层循环\"><a href=\"#第二种方法：两层循环\" class=\"headerlink\" title=\"第二种方法：两层循环\"></a>第二种方法：两层循环</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree2</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    List&lt;Zone&gt; result = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>    <span class=\"hljs-keyword\">for</span> (Zone zone : zoneList) &#123;<br>        <span class=\"hljs-keyword\">if</span> (zone.parentId.equals(<span class=\"hljs-string\">&quot;0&quot;</span>)) &#123;<br>            result.add(zone);<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (Zone child : zoneList) &#123;<br>            <span class=\"hljs-keyword\">if</span> (child.parentId.equals(zone.id)) &#123;<br>                zone.addChildren(child);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"第三种方法：两次遍历\"><a href=\"#第三种方法：两次遍历\" class=\"headerlink\" title=\"第三种方法：两次遍历\"></a>第三种方法：两次遍历</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree3</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    Map&lt;String, List&lt;Zone&gt;&gt; zoneByParentIdMap = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();<br>    zoneList.forEach(zone -&gt; &#123;<br>        List&lt;Zone&gt; children = zoneByParentIdMap.getOrDefault(zone.parentId, <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;());<br>        children.add(zone);<br>        zoneByParentIdMap.put(zone.parentId, children);<br>    &#125;);<br>    zoneList.forEach(zone-&gt;zone.children = zoneByParentIdMap.get(zone.id));<br>    <span class=\"hljs-keyword\">return</span> zoneList.stream()<br>            .filter(v -&gt; v.parentId.equals(<span class=\"hljs-string\">&quot;0&quot;</span>))<br>            .collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>用java8的stream，三行代码实现，Zone里面需要配合增加一个getParentId方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;Zone&gt; <span class=\"hljs-title\">buildTree3</span><span class=\"hljs-params\">(List&lt;Zone&gt; zoneList)</span> </span>&#123;<br>    Map&lt;String, List&lt;Zone&gt;&gt; zoneByParentIdMap = zoneList.stream().collect(Collectors.groupingBy(Zone::getParentId));<br>    zoneList.forEach(zone-&gt;zone.children = zoneByParentIdMap.get(zone.id));<br>    <span class=\"hljs-keyword\">return</span> zoneList.stream().filter(v -&gt; v.parentId.equals(<span class=\"hljs-string\">&quot;0&quot;</span>)).collect(Collectors.toList());<br>&#125;<br><br></code></pre></td></tr></table></figure>\n<h1 id=\"三种方法对比\"><a href=\"#三种方法对比\" class=\"headerlink\" title=\"三种方法对比\"></a>三种方法对比</h1><p>前两种方法的时间复杂度都和叶子节点的个数相关，我们假设叶子节点个数为m<br><strong>方法一:</strong> 用递归的方法，时间复杂度等于：O(n +（n-m）* n)，根据<strong>初始算法</strong>那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n<sup>2</sup>)<br><strong>方法二:</strong> 用两层嵌套循环的方法，时间复杂度等于：O(n +（n-m）* n)，和方法一的时间复杂度是一样的，最终时间复杂度是O(n<sup>2</sup>)<br><strong>方法三:</strong> 用两次遍历的方法，时间复杂度等于：O(3n)，根据<strong>初始算法</strong>那篇文章的计算时间复杂度的方法，可以得到最终时间复杂度是O(n)，但它的空间复杂度比前两种方法稍微大了一点，但是也是线性阶的，所以影响不是特别大。所以第三种方法是个人觉得比较优的一种方法</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>代码执行次数</th>\n<th>时间复杂度</th>\n<th>代码简洁程度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>方法1</td>\n<td>O(n +（n-m）* n)</td>\n<td>指性阶,O(n<sup>2</sup>)</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>方法2</td>\n<td>O(n +（n-m）* n)</td>\n<td>指性阶,O(n<sup>2</sup>)</td>\n<td>良好</td>\n</tr>\n<tr>\n<td>方法3</td>\n<td>O(3n)</td>\n<td>线性阶,O(n</td>\n<td>复杂</td>\n</tr>\n</tbody></table>"},{"title":"如何在多线程中保证i++的原子性","abbrlink":"bc773bb8","date":"2020-09-19T06:32:32.000Z","_content":"> i++是不是一个原子操作？\n\n相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，围绕四个问题：1.什么是原子性操作;2.i++是不是原子操作;3.它为什么不是原子操作;4.如何保证i++的原子性;\n<!-- more-->\n# 剧透\n文章可能有点长（啰嗦），这里先给结论（也希望大家可以看完，在火车上写了好几个小时🤦‍♂️）：\n\n在多线程中，保证i++的原子性：\n1. 最简单暴力的办法，通过java锁，`synchronized`或者`lock`接口的子类，给对象加锁，保证同时只有一个线程在操作\n2. 通过java并发包下的一个原子操作的工具包，AtomicInteger.compareAndSet()方法实现cas(compare and swap,先比较在替换)，保证处理器在处理i++的时候，是原子操作，同时给变量加上volatile修饰符，保证线程的可见性。\n3. 做法类似方法2，不过用getAndIncrement()代替cas赋值操作.\n\n# 什么是原子性\n 原子（Atomic），本意是“不能被继续分割的最小粒子”。原子性在我们计算机中一般表示为**原子操作，即不可被中断的一个或一系列操作**，这个概念在我们的编程语言中，数据库中，和操作系统及处理器中都有出现过。\n# i++是不是原子操作\n这个问题的答案很多人都知道，但是我们还是要用事实来说话，看下面代码\n\n``` java\npublic class AtomicTest {\n\n    public static int count = 0;\n\n    public static void main(String[] args) {\n        List<Thread> threadList = new ArrayList<>();\n        for (int i = 0; i < 5000; i++) {\n            threadList.add(new Thread(() -> {\n                for (int j = 0; j < 10000; j++) {\n                    count++;\n                }\n            }));\n        }\n        for (Thread thread : threadList) {\n            thread.start();\n        }\n        System.out.println(\"count：\" + count);\n    }\n}\n```\n这个程序的很简单，创建50000个线程，执行相同的任务，每个线程执行1000次i++操作，我们期望的结果是50000*1000=50000000；，但是我执行了三次，结果分别为：\n``` absh\ncount: 49764627\ncount: 49729044\ncount: 49584608\n```\n大家可以看到，结果并非我们期望的那样，三次结果各不相同，\n\n为什么\n\n# 多线程的i++为什么不是原子操作？\n## i++在处理器中是如何执行的\ni++虽然在java中是一条命令，但是它在处理器处理的时候，其实是三条命令:\n``` bash\ni = 1; #第一步先从内存中取出i的值\ni + 1 = 1 + 1 = 2; #第二步计算 i + 1结果\ni = 2; #第三步把结果赋值给i\n```\n\n所以如果两个线程同时做i++操作就可能发生下面的情况\n\n1. 线程一获取i的值 i=1;\n2. 线程二获取i的值 i=1;\n3. 线程一计算i+1结果： i+1=1+1=2; \n4. 线程一把结果赋值给i：i+1=1+1=2; \n5. 线程二计算i+1结果： i+1=1+1=2; \n6. 线程二把结果赋值给i：i+1=1+1=2; \n\n最终就会导致两个线程执行完，i的值等于2,解决这个问题，就需要借助我们的并发包下面的原子操作类了，在java中，有很多原子操作类，它们都在 `java.util.concurrent.atomic` 这个包下面，比如：`AtomicBoolean.java`,`AtomicInteger.java`,`AtomicLong.java`等等。\n我们来试一下用`AtomicBoolean.java`来重构一下我们的程序，看看结果如何\n``` java\npublic class AtomicTest {\n\n    public static volatile AtomicInteger count = new AtomicInteger(0);\n\n    public static void main(String[] args) {\n        List<Thread> threadList = new ArrayList<>();\n        for (int i = 0; i < 5000; i++) {\n            threadList.add(new Thread(() -> {\n                for (int j = 0; j < 10000; j++) {\n                    count.getAndIncrement();\n                }\n            }));\n        }\n        for (Thread thread : threadList) {\n            thread.start();\n        }\n        System.out.println(\"atomicCount\" + count.get());\n    }\n}\n```\n同样执行三次，看一下结果：\n```\natomicCount: 49976284\natomicCount: 49989257\natomicCount: 49976830\n\n```\n哪这个结果和上面的结果对比一下，大家会发现，咦？结果离我们预期的稍微有点接近哎。那是因为我们解决了i++在处理器中的原子操作问题，然后看下一个问题\n## 多线程的变量可见性问题\n\n这里需要先介绍一个java关键字，`volatile`,volatile是一个轻量级的synchronized,它的作用是在多线程编程中，保证**变量的可见性**，变量可见性就是说当一个线程修改了某个变量，其他线程并不一定会及时的取到变量值，因为每个线程都有自己本地的变量池。关于为啥在多线程编程中会有变量可见性问题，以及`volatile`和`synchronized`的原理, 如果有人感兴趣的话，我可以在新的文章里写，这里就不多说了。\n\n那么我们用`volatile`来重写一下我们的程序\n\n``` java\npublic class AtomicTest {\n\n    public static volatile AtomicInteger count = new AtomicInteger(0);\n\n    public static void main(String[] args) {\n        List<Thread> threadList = new ArrayList<>();\n        for (int i = 0; i < 5000; i++) {\n            threadList.add(new Thread(() -> {\n                for (int j = 0; j < 10000; j++) {\n                    count.getAndIncrement();\n                }\n            }));\n        }\n        for (Thread thread : threadList) {\n            thread.start();\n        }\n        System.out.println(\"atomicCount\" + count.get());\n    }\n}\n```\n","source":"_posts/java/如何保证I++的原子性.md","raw":"---\ntitle: 如何在多线程中保证i++的原子性\nabbrlink: bc773bb8\ndate: 2020-09-19 14:32:32\ntags:\n---\n> i++是不是一个原子操作？\n\n相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，围绕四个问题：1.什么是原子性操作;2.i++是不是原子操作;3.它为什么不是原子操作;4.如何保证i++的原子性;\n<!-- more-->\n# 剧透\n文章可能有点长（啰嗦），这里先给结论（也希望大家可以看完，在火车上写了好几个小时🤦‍♂️）：\n\n在多线程中，保证i++的原子性：\n1. 最简单暴力的办法，通过java锁，`synchronized`或者`lock`接口的子类，给对象加锁，保证同时只有一个线程在操作\n2. 通过java并发包下的一个原子操作的工具包，AtomicInteger.compareAndSet()方法实现cas(compare and swap,先比较在替换)，保证处理器在处理i++的时候，是原子操作，同时给变量加上volatile修饰符，保证线程的可见性。\n3. 做法类似方法2，不过用getAndIncrement()代替cas赋值操作.\n\n# 什么是原子性\n 原子（Atomic），本意是“不能被继续分割的最小粒子”。原子性在我们计算机中一般表示为**原子操作，即不可被中断的一个或一系列操作**，这个概念在我们的编程语言中，数据库中，和操作系统及处理器中都有出现过。\n# i++是不是原子操作\n这个问题的答案很多人都知道，但是我们还是要用事实来说话，看下面代码\n\n``` java\npublic class AtomicTest {\n\n    public static int count = 0;\n\n    public static void main(String[] args) {\n        List<Thread> threadList = new ArrayList<>();\n        for (int i = 0; i < 5000; i++) {\n            threadList.add(new Thread(() -> {\n                for (int j = 0; j < 10000; j++) {\n                    count++;\n                }\n            }));\n        }\n        for (Thread thread : threadList) {\n            thread.start();\n        }\n        System.out.println(\"count：\" + count);\n    }\n}\n```\n这个程序的很简单，创建50000个线程，执行相同的任务，每个线程执行1000次i++操作，我们期望的结果是50000*1000=50000000；，但是我执行了三次，结果分别为：\n``` absh\ncount: 49764627\ncount: 49729044\ncount: 49584608\n```\n大家可以看到，结果并非我们期望的那样，三次结果各不相同，\n\n为什么\n\n# 多线程的i++为什么不是原子操作？\n## i++在处理器中是如何执行的\ni++虽然在java中是一条命令，但是它在处理器处理的时候，其实是三条命令:\n``` bash\ni = 1; #第一步先从内存中取出i的值\ni + 1 = 1 + 1 = 2; #第二步计算 i + 1结果\ni = 2; #第三步把结果赋值给i\n```\n\n所以如果两个线程同时做i++操作就可能发生下面的情况\n\n1. 线程一获取i的值 i=1;\n2. 线程二获取i的值 i=1;\n3. 线程一计算i+1结果： i+1=1+1=2; \n4. 线程一把结果赋值给i：i+1=1+1=2; \n5. 线程二计算i+1结果： i+1=1+1=2; \n6. 线程二把结果赋值给i：i+1=1+1=2; \n\n最终就会导致两个线程执行完，i的值等于2,解决这个问题，就需要借助我们的并发包下面的原子操作类了，在java中，有很多原子操作类，它们都在 `java.util.concurrent.atomic` 这个包下面，比如：`AtomicBoolean.java`,`AtomicInteger.java`,`AtomicLong.java`等等。\n我们来试一下用`AtomicBoolean.java`来重构一下我们的程序，看看结果如何\n``` java\npublic class AtomicTest {\n\n    public static volatile AtomicInteger count = new AtomicInteger(0);\n\n    public static void main(String[] args) {\n        List<Thread> threadList = new ArrayList<>();\n        for (int i = 0; i < 5000; i++) {\n            threadList.add(new Thread(() -> {\n                for (int j = 0; j < 10000; j++) {\n                    count.getAndIncrement();\n                }\n            }));\n        }\n        for (Thread thread : threadList) {\n            thread.start();\n        }\n        System.out.println(\"atomicCount\" + count.get());\n    }\n}\n```\n同样执行三次，看一下结果：\n```\natomicCount: 49976284\natomicCount: 49989257\natomicCount: 49976830\n\n```\n哪这个结果和上面的结果对比一下，大家会发现，咦？结果离我们预期的稍微有点接近哎。那是因为我们解决了i++在处理器中的原子操作问题，然后看下一个问题\n## 多线程的变量可见性问题\n\n这里需要先介绍一个java关键字，`volatile`,volatile是一个轻量级的synchronized,它的作用是在多线程编程中，保证**变量的可见性**，变量可见性就是说当一个线程修改了某个变量，其他线程并不一定会及时的取到变量值，因为每个线程都有自己本地的变量池。关于为啥在多线程编程中会有变量可见性问题，以及`volatile`和`synchronized`的原理, 如果有人感兴趣的话，我可以在新的文章里写，这里就不多说了。\n\n那么我们用`volatile`来重写一下我们的程序\n\n``` java\npublic class AtomicTest {\n\n    public static volatile AtomicInteger count = new AtomicInteger(0);\n\n    public static void main(String[] args) {\n        List<Thread> threadList = new ArrayList<>();\n        for (int i = 0; i < 5000; i++) {\n            threadList.add(new Thread(() -> {\n                for (int j = 0; j < 10000; j++) {\n                    count.getAndIncrement();\n                }\n            }));\n        }\n        for (Thread thread : threadList) {\n            thread.start();\n        }\n        System.out.println(\"atomicCount\" + count.get());\n    }\n}\n```\n","slug":"java/如何保证I++的原子性","published":1,"updated":"2021-06-29T07:52:43.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqhrqigw0002t0uv8d23067j","content":"<blockquote>\n<p>i++是不是一个原子操作？</p>\n</blockquote>\n<p>相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，围绕四个问题：1.什么是原子性操作;2.i++是不是原子操作;3.它为什么不是原子操作;4.如何保证i++的原子性;</p>\n<span id=\"more\"></span>\n<h1 id=\"剧透\"><a href=\"#剧透\" class=\"headerlink\" title=\"剧透\"></a>剧透</h1><p>文章可能有点长（啰嗦），这里先给结论（也希望大家可以看完，在火车上写了好几个小时🤦‍♂️）：</p>\n<p>在多线程中，保证i++的原子性：</p>\n<ol>\n<li>最简单暴力的办法，通过java锁，<code>synchronized</code>或者<code>lock</code>接口的子类，给对象加锁，保证同时只有一个线程在操作</li>\n<li>通过java并发包下的一个原子操作的工具包，AtomicInteger.compareAndSet()方法实现cas(compare and swap,先比较在替换)，保证处理器在处理i++的时候，是原子操作，同时给变量加上volatile修饰符，保证线程的可见性。</li>\n<li>做法类似方法2，不过用getAndIncrement()代替cas赋值操作.</li>\n</ol>\n<h1 id=\"什么是原子性\"><a href=\"#什么是原子性\" class=\"headerlink\" title=\"什么是原子性\"></a>什么是原子性</h1><p> 原子（Atomic），本意是“不能被继续分割的最小粒子”。原子性在我们计算机中一般表示为<strong>原子操作，即不可被中断的一个或一系列操作</strong>，这个概念在我们的编程语言中，数据库中，和操作系统及处理器中都有出现过。</p>\n<h1 id=\"i-是不是原子操作\"><a href=\"#i-是不是原子操作\" class=\"headerlink\" title=\"i++是不是原子操作\"></a>i++是不是原子操作</h1><p>这个问题的答案很多人都知道，但是我们还是要用事实来说话，看下面代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AtomicTest</span> </span>&#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        List&lt;Thread&gt; threadList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5000</span>; i++) &#123;<br>            threadList.add(<span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;<br>                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10000</span>; j++) &#123;<br>                    count++;<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (Thread thread : threadList) &#123;<br>            thread.start();<br>        &#125;<br>        System.out.println(<span class=\"hljs-string\">&quot;count：&quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<p>这个程序的很简单，创建50000个线程，执行相同的任务，每个线程执行1000次i++操作，我们期望的结果是50000*1000=50000000；，但是我执行了三次，结果分别为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs absh\">count: 49764627<br>count: 49729044<br>count: 49584608<br></code></pre></div></td></tr></table></figure>\n<p>大家可以看到，结果并非我们期望的那样，三次结果各不相同，</p>\n<p>为什么</p>\n<h1 id=\"多线程的i-为什么不是原子操作？\"><a href=\"#多线程的i-为什么不是原子操作？\" class=\"headerlink\" title=\"多线程的i++为什么不是原子操作？\"></a>多线程的i++为什么不是原子操作？</h1><h2 id=\"i-在处理器中是如何执行的\"><a href=\"#i-在处理器中是如何执行的\" class=\"headerlink\" title=\"i++在处理器中是如何执行的\"></a>i++在处理器中是如何执行的</h2><p>i++虽然在java中是一条命令，但是它在处理器处理的时候，其实是三条命令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs bash\">i = 1; <span class=\"hljs-comment\">#第一步先从内存中取出i的值</span><br>i + 1 = 1 + 1 = 2; <span class=\"hljs-comment\">#第二步计算 i + 1结果</span><br>i = 2; <span class=\"hljs-comment\">#第三步把结果赋值给i</span><br></code></pre></div></td></tr></table></figure>\n\n<p>所以如果两个线程同时做i++操作就可能发生下面的情况</p>\n<ol>\n<li>线程一获取i的值 i=1;</li>\n<li>线程二获取i的值 i=1;</li>\n<li>线程一计算i+1结果： i+1=1+1=2; </li>\n<li>线程一把结果赋值给i：i+1=1+1=2; </li>\n<li>线程二计算i+1结果： i+1=1+1=2; </li>\n<li>线程二把结果赋值给i：i+1=1+1=2; </li>\n</ol>\n<p>最终就会导致两个线程执行完，i的值等于2,解决这个问题，就需要借助我们的并发包下面的原子操作类了，在java中，有很多原子操作类，它们都在 <code>java.util.concurrent.atomic</code> 这个包下面，比如：<code>AtomicBoolean.java</code>,<code>AtomicInteger.java</code>,<code>AtomicLong.java</code>等等。<br>我们来试一下用<code>AtomicBoolean.java</code>来重构一下我们的程序，看看结果如何</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AtomicTest</span> </span>&#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">volatile</span> AtomicInteger count = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        List&lt;Thread&gt; threadList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5000</span>; i++) &#123;<br>            threadList.add(<span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;<br>                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10000</span>; j++) &#123;<br>                    count.getAndIncrement();<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (Thread thread : threadList) &#123;<br>            thread.start();<br>        &#125;<br>        System.out.println(<span class=\"hljs-string\">&quot;atomicCount&quot;</span> + count.get());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<p>同样执行三次，看一下结果：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">atomicCount</span>: <span class=\"hljs-number\">49976284</span><br><span class=\"hljs-attribute\">atomicCount</span>: <span class=\"hljs-number\">49989257</span><br><span class=\"hljs-attribute\">atomicCount</span>: <span class=\"hljs-number\">49976830</span><br><br></code></pre></div></td></tr></table></figure>\n<p>哪这个结果和上面的结果对比一下，大家会发现，咦？结果离我们预期的稍微有点接近哎。那是因为我们解决了i++在处理器中的原子操作问题，然后看下一个问题</p>\n<h2 id=\"多线程的变量可见性问题\"><a href=\"#多线程的变量可见性问题\" class=\"headerlink\" title=\"多线程的变量可见性问题\"></a>多线程的变量可见性问题</h2><p>这里需要先介绍一个java关键字，<code>volatile</code>,volatile是一个轻量级的synchronized,它的作用是在多线程编程中，保证<strong>变量的可见性</strong>，变量可见性就是说当一个线程修改了某个变量，其他线程并不一定会及时的取到变量值，因为每个线程都有自己本地的变量池。关于为啥在多线程编程中会有变量可见性问题，以及<code>volatile</code>和<code>synchronized</code>的原理, 如果有人感兴趣的话，我可以在新的文章里写，这里就不多说了。</p>\n<p>那么我们用<code>volatile</code>来重写一下我们的程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AtomicTest</span> </span>&#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">volatile</span> AtomicInteger count = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        List&lt;Thread&gt; threadList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5000</span>; i++) &#123;<br>            threadList.add(<span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;<br>                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10000</span>; j++) &#123;<br>                    count.getAndIncrement();<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (Thread thread : threadList) &#123;<br>            thread.start();<br>        &#125;<br>        System.out.println(<span class=\"hljs-string\">&quot;atomicCount&quot;</span> + count.get());<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>i++是不是一个原子操作？</p>\n</blockquote>\n<p>相信很多人都知道，它并不是原子操作，为什么要写这篇文章，这也是我看了java并发编程中的第二章原子性相关的内容，重新思考的一个问题，如何保证i++的原子性？既然是总结，那我就从头开始理一下，围绕四个问题：1.什么是原子性操作;2.i++是不是原子操作;3.它为什么不是原子操作;4.如何保证i++的原子性;</p>","more":"<h1 id=\"剧透\"><a href=\"#剧透\" class=\"headerlink\" title=\"剧透\"></a>剧透</h1><p>文章可能有点长（啰嗦），这里先给结论（也希望大家可以看完，在火车上写了好几个小时🤦‍♂️）：</p>\n<p>在多线程中，保证i++的原子性：</p>\n<ol>\n<li>最简单暴力的办法，通过java锁，<code>synchronized</code>或者<code>lock</code>接口的子类，给对象加锁，保证同时只有一个线程在操作</li>\n<li>通过java并发包下的一个原子操作的工具包，AtomicInteger.compareAndSet()方法实现cas(compare and swap,先比较在替换)，保证处理器在处理i++的时候，是原子操作，同时给变量加上volatile修饰符，保证线程的可见性。</li>\n<li>做法类似方法2，不过用getAndIncrement()代替cas赋值操作.</li>\n</ol>\n<h1 id=\"什么是原子性\"><a href=\"#什么是原子性\" class=\"headerlink\" title=\"什么是原子性\"></a>什么是原子性</h1><p> 原子（Atomic），本意是“不能被继续分割的最小粒子”。原子性在我们计算机中一般表示为<strong>原子操作，即不可被中断的一个或一系列操作</strong>，这个概念在我们的编程语言中，数据库中，和操作系统及处理器中都有出现过。</p>\n<h1 id=\"i-是不是原子操作\"><a href=\"#i-是不是原子操作\" class=\"headerlink\" title=\"i++是不是原子操作\"></a>i++是不是原子操作</h1><p>这个问题的答案很多人都知道，但是我们还是要用事实来说话，看下面代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AtomicTest</span> </span>&#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        List&lt;Thread&gt; threadList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5000</span>; i++) &#123;<br>            threadList.add(<span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;<br>                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10000</span>; j++) &#123;<br>                    count++;<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (Thread thread : threadList) &#123;<br>            thread.start();<br>        &#125;<br>        System.out.println(<span class=\"hljs-string\">&quot;count：&quot;</span> + count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这个程序的很简单，创建50000个线程，执行相同的任务，每个线程执行1000次i++操作，我们期望的结果是50000*1000=50000000；，但是我执行了三次，结果分别为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs absh\">count: 49764627<br>count: 49729044<br>count: 49584608<br></code></pre></td></tr></table></figure>\n<p>大家可以看到，结果并非我们期望的那样，三次结果各不相同，</p>\n<p>为什么</p>\n<h1 id=\"多线程的i-为什么不是原子操作？\"><a href=\"#多线程的i-为什么不是原子操作？\" class=\"headerlink\" title=\"多线程的i++为什么不是原子操作？\"></a>多线程的i++为什么不是原子操作？</h1><h2 id=\"i-在处理器中是如何执行的\"><a href=\"#i-在处理器中是如何执行的\" class=\"headerlink\" title=\"i++在处理器中是如何执行的\"></a>i++在处理器中是如何执行的</h2><p>i++虽然在java中是一条命令，但是它在处理器处理的时候，其实是三条命令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">i = 1; <span class=\"hljs-comment\">#第一步先从内存中取出i的值</span><br>i + 1 = 1 + 1 = 2; <span class=\"hljs-comment\">#第二步计算 i + 1结果</span><br>i = 2; <span class=\"hljs-comment\">#第三步把结果赋值给i</span><br></code></pre></td></tr></table></figure>\n\n<p>所以如果两个线程同时做i++操作就可能发生下面的情况</p>\n<ol>\n<li>线程一获取i的值 i=1;</li>\n<li>线程二获取i的值 i=1;</li>\n<li>线程一计算i+1结果： i+1=1+1=2; </li>\n<li>线程一把结果赋值给i：i+1=1+1=2; </li>\n<li>线程二计算i+1结果： i+1=1+1=2; </li>\n<li>线程二把结果赋值给i：i+1=1+1=2; </li>\n</ol>\n<p>最终就会导致两个线程执行完，i的值等于2,解决这个问题，就需要借助我们的并发包下面的原子操作类了，在java中，有很多原子操作类，它们都在 <code>java.util.concurrent.atomic</code> 这个包下面，比如：<code>AtomicBoolean.java</code>,<code>AtomicInteger.java</code>,<code>AtomicLong.java</code>等等。<br>我们来试一下用<code>AtomicBoolean.java</code>来重构一下我们的程序，看看结果如何</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AtomicTest</span> </span>&#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">volatile</span> AtomicInteger count = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        List&lt;Thread&gt; threadList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5000</span>; i++) &#123;<br>            threadList.add(<span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;<br>                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10000</span>; j++) &#123;<br>                    count.getAndIncrement();<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (Thread thread : threadList) &#123;<br>            thread.start();<br>        &#125;<br>        System.out.println(<span class=\"hljs-string\">&quot;atomicCount&quot;</span> + count.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>同样执行三次，看一下结果：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">atomicCount</span>: <span class=\"hljs-number\">49976284</span><br><span class=\"hljs-attribute\">atomicCount</span>: <span class=\"hljs-number\">49989257</span><br><span class=\"hljs-attribute\">atomicCount</span>: <span class=\"hljs-number\">49976830</span><br><br></code></pre></td></tr></table></figure>\n<p>哪这个结果和上面的结果对比一下，大家会发现，咦？结果离我们预期的稍微有点接近哎。那是因为我们解决了i++在处理器中的原子操作问题，然后看下一个问题</p>\n<h2 id=\"多线程的变量可见性问题\"><a href=\"#多线程的变量可见性问题\" class=\"headerlink\" title=\"多线程的变量可见性问题\"></a>多线程的变量可见性问题</h2><p>这里需要先介绍一个java关键字，<code>volatile</code>,volatile是一个轻量级的synchronized,它的作用是在多线程编程中，保证<strong>变量的可见性</strong>，变量可见性就是说当一个线程修改了某个变量，其他线程并不一定会及时的取到变量值，因为每个线程都有自己本地的变量池。关于为啥在多线程编程中会有变量可见性问题，以及<code>volatile</code>和<code>synchronized</code>的原理, 如果有人感兴趣的话，我可以在新的文章里写，这里就不多说了。</p>\n<p>那么我们用<code>volatile</code>来重写一下我们的程序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AtomicTest</span> </span>&#123;<br><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">volatile</span> AtomicInteger count = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">0</span>);<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;<br>        List&lt;Thread&gt; threadList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5000</span>; i++) &#123;<br>            threadList.add(<span class=\"hljs-keyword\">new</span> Thread(() -&gt; &#123;<br>                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10000</span>; j++) &#123;<br>                    count.getAndIncrement();<br>                &#125;<br>            &#125;));<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (Thread thread : threadList) &#123;<br>            thread.start();<br>        &#125;<br>        System.out.println(<span class=\"hljs-string\">&quot;atomicCount&quot;</span> + count.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"数据结构与算法（一）：初识算法","date":"2020-03-14T06:37:58.000Z","abbrlink":"8ddf18fb","_content":"## 什么是算法？\n\n>“算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”\n> ------摘录来自: 程杰. “大话数据结构。”\n\n<!-- more -->\n\n我个人理解，算法就是解决某一类问题的方法。我们的前辈总结了非常多优秀的算法，比如用于排序的冒泡排序、选择排序、插入排序算法，用于查找的二分查找、散列查找、顺序查找算法等。\n\n## 为什么要学习算法？\n1. 算法是编程的基础，不管学习什么语言，算法早晚要学的，它是我们进阶到高级开发工程师所必须要掌握的知识之一。\n2. 可以培养自己写出高效的代码\n3. 锻炼自己的逻辑思维能力\n4. ~~ 面试，找工作。~~🤦‍♂️\n\n## 举一个简单的算法例子\n\n大多数人都应该听说过著名数学家高斯的一个小故事：高斯在上小学的时候，老师布置了一个数学任务，让同学们对自然数从1到100求和。他很快就得出结果：5050。他的解释是这样的：\n\n```\n    num = 1 + 2 + 3 + ... + 99 + 100;\n    num = 100 + 99 + ... + 3 + 2 + 1;\n2 * num = 101 + 101 +... + 101 + 101; // 一共100个101相加\n    num = 101 * 100 / 2 = 5050；\n```\n\n这道题如果用代码来实现的话，有两种解法：\n1. **普通解法**\n\n``` java \npublic int computeSum(int n) {\n    int sum = 0;\n    for (int i = 1; i < n; i++) {\n        sum += i;\n    }\n    return num;\n}\n```\n2. **高斯的解法**\n\n``` java \npublic int computeSum(int n) {\n    int sum =  (1 + n) * n / 2;\n    return num;\n}\n```\n即使我们没有学过算法，我们也能看出来，这两种计算方法，第二种显然更加的高效，但是如果让我们来评价第二种算法有多高效，它的**时间复杂度**是多少，**空间复杂度**是多少，可能就需要我们了解一些算法的度量方法之后，才能准确的表达出来。\n   \n---\n\n下面我们从算法的定义，特性，要求，度量方法来完整的了解一下算法\n\n## 算法的定义\n>“**算法是描述解决问题的方法。**算法（Algorithm）这个单词最早出现在波斯数学家阿勒·花刺子密在公元825年（相当于我们中国的唐朝时期）所写的《印度数字算术》中。如今普遍认可的对算法的定义是：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”\n\n## 算法的特性\n算法有五个基本特性：输入、输出、有穷性，确定性和可行性。\n\n1. **输入：**待解决问题的条件，一般来说，一个算法会有一个或多个输入参数。（也可以是零个输入参数，如：打印hello world）\n2. **输出：** 待解决问题的结果，输出的形式可能是打印控制台，或者返回一个数据。一个算法一定至少有一个输出。\n3. **有穷性：** 指的是解决问题的步骤，必须是有限的。从我们写代码角度来理解的话，就是不能出现死循环。这个有限的步骤，也是有一定边界的，如果我们写了一个算法，需要一百年才能计算出结果，虽然说步骤可能是有限的，但是就算一百年不断电，一百年之后谁能验证这个结果是否正确呢😂，所以说这个“有限”，一定要合理。\n4. **确定性：**相同的输入只能有唯一的结果，算法的每一步骤的意义都被精确定义而无歧义；\n5. **可行性：**算法必须可以被实现。也就是说它每一步都必须可以转换为程序上机运行，并且得到正确结果。\n\n## 算法的要求\n\n评价一个算法是否有效，是不是够好，有四个指标：正确性、可读性、健壮性、时间效率高和存储量低.\n\n1. **正确性**：这是一个算法最基本的条件，它指的是，算法至少应该根据问题的描述和输入，得到一个正确的输出。\n2. **可读性**：算法设计的另一目的是为了便于阅读、理解和交流。（个人理解，这个指标的优先级在其他三个指标之后）\n3. **健壮性**：当输入不合法的参数，我们要保证我们的算法可以正常执行，并返回结果，而不是直接程序报错。\n4. **时间效率高和存储量低**： 这是评估一个算法是不是好的算法的指标，指的是这个算法执行的时间是不是足够短，消耗的内存是不是足够小。\n\n总的来说，一个有效算法必须满足正确性和健壮性，如果同时能满足时间效率高和存储量低以及可读性，那么它就是一个有效的，并且是一个优秀的算法。\n## 算法的度量方法\n\n算法的度量方法有两种：1. 事后统计法；2. 事前估算法\n\n### 事后统计法\n事前统计法，主要是通过一批固定的测试数据，让不同算法的程序去执行，得到结果后，统计出不同算法的结果进行统计分析来判断不同算法的效率高低。\n虽然这样也可以计算出算法的效率高低。但是它的缺点也很明显：\n- 硬件要求完全一致；\n- 测试数据设计困难，测试数据必须考虑的足够全面；\n- 如果算法比较复杂，这个统计的时间可能会需要很久；\n\n所以一般来说，我们一般不考虑用这种方法来度量算法\n### 事前估算法\n先来看一下影响程序执行效率的因素：1.硬件；2.编译器；3.程序指令的执行次数；4.问题的条件和输入；\n通过分析我们发现，第1，2，4个因素都是算法无法影响的，所以我们只关注程序代码，那么我们再回到上面那道题，计算1-100的和，我们看一下两种算法的程序代码\n1. **普通解法**\n\n``` java \npublic int computeSum(int n) {\n    int sum = 0; //执行1次\n    for (int i = 1; i < n; i++) { //int i = 1执行1次，i < n 执行 n 次，i++ 执行 n 次\n        sum += i; //执行n次\n    }\n    return num;\n}\n```\n整个程序代码一共执行了 1+1+n+n+n+n=4n+2次\n2. **高斯的解法**\n\n``` java \npublic int computeSum(int n) {\n    int sum =  (1 + n) * n / 2; // 执行1次\n    return num;\n}\n```\n整个程序代码一共执行了 1次\n\n**所以，显而易见，1 < 4n+2,第二种算法执行效率更高**，第一种的时间复杂度，我们记作O(n),表示线性阶，第二种时间复杂度，我们计作O(1)，表示常数阶；\n\n## 算法的时间复杂度\n>“在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。\n这样用大写O( )来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。”\n------摘录来自: 程杰. “大话数据结构。” \n\n简单理解，算法的时间复杂度和语句执行的次数紧密相关，如上面的提到的普通解法的算法执行次数:4n+2,我们用O(n)表示这个算法的时间复杂度。为什么不是O(4n+2)，或者O(4n)? 接着看下面的推导大O阶的方法：\n\n>1．用常数1取代运行时间中的所有加法常数。\n2．在修改后的运行次数函数中，只保留最高阶项。\n3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。取最高阶的项并忽略其常系数\n------摘录来自: 程杰. “大话数据结构。” \n\n接下来说为什么上面那个算法的执行次数是4n+2，但它的时间复杂度是O(n),\n根据推导大O的方法1，可以得到 4n + 2 = O(4n + 1)；\n根据推导大O的方法2，只保留最高阶，4n + 2 =O(4n);\n根据推导大O的方法3，最高阶项是4n，那么4n相乘的常熟是4，就需要除以4，最终结果是 4n + 2 = O(4n / 4) = O(n);\n\n下面是常见的时间复杂度及例子\n\n| 函数阶             | 非正式术语 | 执行次数的例子                      |\n|-------------------|----------|-----------------------------------|\n|O(1)               |常数阶     |1,2,12                             |\n|O(n)               |线性阶     |4n+2,2n+1,n+10                     |\n|O(n<sup>2</sup>)   |平方阶     |3n2+2n+1                           |\n|O(logn)            |对数阶     |5log2n+20                          |\n|O(nlogn)           |nlogn阶   |2n+3nlog2n+19                      |\n|O(n<sup>3</sup>)   |立方阶     |6n<sup>3</sup>+2n+3n+4             |\n|O(2<sup>n</sup>)   |指数阶     |2<sup>n</sup>                      |\n|O(n!)              |--     |无                                 |\n|O(n<sup>n</sup>)   |--     |无                                 |\n\n最后两种时间复杂度很少用到，常用的时间复杂度所耗费的时间从小到大依次是：\nO(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)\n\n## 空间复杂度\n\n>“一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)”\n------摘录来自: 程杰. “大话数据结构。” \n\n空间复杂度一般我们也用大O来表示，问题的输入、条件、输出变量取决于问题，所以不算做算法本身的存储空间，算法的存储空间只和其他的辅助变量有关。只要辅助变量的数量是常数，也就是说空间复杂度为O(1),那么这个算法就可以称为**原地工作**，原地工作这个词在leetcode题目中可能会出现。\n\n对于算法的空间复杂度一般来说讲的比较少，计算机内存越来越大了，只要不是特别离谱，我们一般情况下，可能会故意通过空间来换时间，像系统设计中的缓存，就是很好的例子，所以空间复杂度我们大概了解就行，不过多在介绍了。\n\n\n## 一张脑图概括\n好了最后我们用一张图来总结一下这篇文章的内容\n\n。。。\n。。。\n图片加载失败…… \n~~我只是困了想睡觉了🤦‍♂️~~","source":"_posts/数据结构与算法/数据结构与算法（一）：初识算法.md","raw":"---\ntitle: 数据结构与算法（一）：初识算法\ndate: 2020-03-14 14:37:58\ntags: [学习笔记, 数据结构与算法]\ncategory: 数据结构与算法\nabbrlink: 8ddf18fb\n---\n## 什么是算法？\n\n>“算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”\n> ------摘录来自: 程杰. “大话数据结构。”\n\n<!-- more -->\n\n我个人理解，算法就是解决某一类问题的方法。我们的前辈总结了非常多优秀的算法，比如用于排序的冒泡排序、选择排序、插入排序算法，用于查找的二分查找、散列查找、顺序查找算法等。\n\n## 为什么要学习算法？\n1. 算法是编程的基础，不管学习什么语言，算法早晚要学的，它是我们进阶到高级开发工程师所必须要掌握的知识之一。\n2. 可以培养自己写出高效的代码\n3. 锻炼自己的逻辑思维能力\n4. ~~ 面试，找工作。~~🤦‍♂️\n\n## 举一个简单的算法例子\n\n大多数人都应该听说过著名数学家高斯的一个小故事：高斯在上小学的时候，老师布置了一个数学任务，让同学们对自然数从1到100求和。他很快就得出结果：5050。他的解释是这样的：\n\n```\n    num = 1 + 2 + 3 + ... + 99 + 100;\n    num = 100 + 99 + ... + 3 + 2 + 1;\n2 * num = 101 + 101 +... + 101 + 101; // 一共100个101相加\n    num = 101 * 100 / 2 = 5050；\n```\n\n这道题如果用代码来实现的话，有两种解法：\n1. **普通解法**\n\n``` java \npublic int computeSum(int n) {\n    int sum = 0;\n    for (int i = 1; i < n; i++) {\n        sum += i;\n    }\n    return num;\n}\n```\n2. **高斯的解法**\n\n``` java \npublic int computeSum(int n) {\n    int sum =  (1 + n) * n / 2;\n    return num;\n}\n```\n即使我们没有学过算法，我们也能看出来，这两种计算方法，第二种显然更加的高效，但是如果让我们来评价第二种算法有多高效，它的**时间复杂度**是多少，**空间复杂度**是多少，可能就需要我们了解一些算法的度量方法之后，才能准确的表达出来。\n   \n---\n\n下面我们从算法的定义，特性，要求，度量方法来完整的了解一下算法\n\n## 算法的定义\n>“**算法是描述解决问题的方法。**算法（Algorithm）这个单词最早出现在波斯数学家阿勒·花刺子密在公元825年（相当于我们中国的唐朝时期）所写的《印度数字算术》中。如今普遍认可的对算法的定义是：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”\n\n## 算法的特性\n算法有五个基本特性：输入、输出、有穷性，确定性和可行性。\n\n1. **输入：**待解决问题的条件，一般来说，一个算法会有一个或多个输入参数。（也可以是零个输入参数，如：打印hello world）\n2. **输出：** 待解决问题的结果，输出的形式可能是打印控制台，或者返回一个数据。一个算法一定至少有一个输出。\n3. **有穷性：** 指的是解决问题的步骤，必须是有限的。从我们写代码角度来理解的话，就是不能出现死循环。这个有限的步骤，也是有一定边界的，如果我们写了一个算法，需要一百年才能计算出结果，虽然说步骤可能是有限的，但是就算一百年不断电，一百年之后谁能验证这个结果是否正确呢😂，所以说这个“有限”，一定要合理。\n4. **确定性：**相同的输入只能有唯一的结果，算法的每一步骤的意义都被精确定义而无歧义；\n5. **可行性：**算法必须可以被实现。也就是说它每一步都必须可以转换为程序上机运行，并且得到正确结果。\n\n## 算法的要求\n\n评价一个算法是否有效，是不是够好，有四个指标：正确性、可读性、健壮性、时间效率高和存储量低.\n\n1. **正确性**：这是一个算法最基本的条件，它指的是，算法至少应该根据问题的描述和输入，得到一个正确的输出。\n2. **可读性**：算法设计的另一目的是为了便于阅读、理解和交流。（个人理解，这个指标的优先级在其他三个指标之后）\n3. **健壮性**：当输入不合法的参数，我们要保证我们的算法可以正常执行，并返回结果，而不是直接程序报错。\n4. **时间效率高和存储量低**： 这是评估一个算法是不是好的算法的指标，指的是这个算法执行的时间是不是足够短，消耗的内存是不是足够小。\n\n总的来说，一个有效算法必须满足正确性和健壮性，如果同时能满足时间效率高和存储量低以及可读性，那么它就是一个有效的，并且是一个优秀的算法。\n## 算法的度量方法\n\n算法的度量方法有两种：1. 事后统计法；2. 事前估算法\n\n### 事后统计法\n事前统计法，主要是通过一批固定的测试数据，让不同算法的程序去执行，得到结果后，统计出不同算法的结果进行统计分析来判断不同算法的效率高低。\n虽然这样也可以计算出算法的效率高低。但是它的缺点也很明显：\n- 硬件要求完全一致；\n- 测试数据设计困难，测试数据必须考虑的足够全面；\n- 如果算法比较复杂，这个统计的时间可能会需要很久；\n\n所以一般来说，我们一般不考虑用这种方法来度量算法\n### 事前估算法\n先来看一下影响程序执行效率的因素：1.硬件；2.编译器；3.程序指令的执行次数；4.问题的条件和输入；\n通过分析我们发现，第1，2，4个因素都是算法无法影响的，所以我们只关注程序代码，那么我们再回到上面那道题，计算1-100的和，我们看一下两种算法的程序代码\n1. **普通解法**\n\n``` java \npublic int computeSum(int n) {\n    int sum = 0; //执行1次\n    for (int i = 1; i < n; i++) { //int i = 1执行1次，i < n 执行 n 次，i++ 执行 n 次\n        sum += i; //执行n次\n    }\n    return num;\n}\n```\n整个程序代码一共执行了 1+1+n+n+n+n=4n+2次\n2. **高斯的解法**\n\n``` java \npublic int computeSum(int n) {\n    int sum =  (1 + n) * n / 2; // 执行1次\n    return num;\n}\n```\n整个程序代码一共执行了 1次\n\n**所以，显而易见，1 < 4n+2,第二种算法执行效率更高**，第一种的时间复杂度，我们记作O(n),表示线性阶，第二种时间复杂度，我们计作O(1)，表示常数阶；\n\n## 算法的时间复杂度\n>“在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。\n这样用大写O( )来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。”\n------摘录来自: 程杰. “大话数据结构。” \n\n简单理解，算法的时间复杂度和语句执行的次数紧密相关，如上面的提到的普通解法的算法执行次数:4n+2,我们用O(n)表示这个算法的时间复杂度。为什么不是O(4n+2)，或者O(4n)? 接着看下面的推导大O阶的方法：\n\n>1．用常数1取代运行时间中的所有加法常数。\n2．在修改后的运行次数函数中，只保留最高阶项。\n3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。取最高阶的项并忽略其常系数\n------摘录来自: 程杰. “大话数据结构。” \n\n接下来说为什么上面那个算法的执行次数是4n+2，但它的时间复杂度是O(n),\n根据推导大O的方法1，可以得到 4n + 2 = O(4n + 1)；\n根据推导大O的方法2，只保留最高阶，4n + 2 =O(4n);\n根据推导大O的方法3，最高阶项是4n，那么4n相乘的常熟是4，就需要除以4，最终结果是 4n + 2 = O(4n / 4) = O(n);\n\n下面是常见的时间复杂度及例子\n\n| 函数阶             | 非正式术语 | 执行次数的例子                      |\n|-------------------|----------|-----------------------------------|\n|O(1)               |常数阶     |1,2,12                             |\n|O(n)               |线性阶     |4n+2,2n+1,n+10                     |\n|O(n<sup>2</sup>)   |平方阶     |3n2+2n+1                           |\n|O(logn)            |对数阶     |5log2n+20                          |\n|O(nlogn)           |nlogn阶   |2n+3nlog2n+19                      |\n|O(n<sup>3</sup>)   |立方阶     |6n<sup>3</sup>+2n+3n+4             |\n|O(2<sup>n</sup>)   |指数阶     |2<sup>n</sup>                      |\n|O(n!)              |--     |无                                 |\n|O(n<sup>n</sup>)   |--     |无                                 |\n\n最后两种时间复杂度很少用到，常用的时间复杂度所耗费的时间从小到大依次是：\nO(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)\n\n## 空间复杂度\n\n>“一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)”\n------摘录来自: 程杰. “大话数据结构。” \n\n空间复杂度一般我们也用大O来表示，问题的输入、条件、输出变量取决于问题，所以不算做算法本身的存储空间，算法的存储空间只和其他的辅助变量有关。只要辅助变量的数量是常数，也就是说空间复杂度为O(1),那么这个算法就可以称为**原地工作**，原地工作这个词在leetcode题目中可能会出现。\n\n对于算法的空间复杂度一般来说讲的比较少，计算机内存越来越大了，只要不是特别离谱，我们一般情况下，可能会故意通过空间来换时间，像系统设计中的缓存，就是很好的例子，所以空间复杂度我们大概了解就行，不过多在介绍了。\n\n\n## 一张脑图概括\n好了最后我们用一张图来总结一下这篇文章的内容\n\n。。。\n。。。\n图片加载失败…… \n~~我只是困了想睡觉了🤦‍♂️~~","slug":"数据结构与算法/数据结构与算法（一）：初识算法","published":1,"updated":"2021-06-29T06:27:03.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqhrqigz0003t0uv3uddgo94","content":"<h2 id=\"什么是算法？\"><a href=\"#什么是算法？\" class=\"headerlink\" title=\"什么是算法？\"></a>什么是算法？</h2><blockquote>\n<p>“算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”<br>——摘录来自: 程杰. “大话数据结构。”</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>我个人理解，算法就是解决某一类问题的方法。我们的前辈总结了非常多优秀的算法，比如用于排序的冒泡排序、选择排序、插入排序算法，用于查找的二分查找、散列查找、顺序查找算法等。</p>\n<h2 id=\"为什么要学习算法？\"><a href=\"#为什么要学习算法？\" class=\"headerlink\" title=\"为什么要学习算法？\"></a>为什么要学习算法？</h2><ol>\n<li>算法是编程的基础，不管学习什么语言，算法早晚要学的，它是我们进阶到高级开发工程师所必须要掌握的知识之一。</li>\n<li>可以培养自己写出高效的代码</li>\n<li>锻炼自己的逻辑思维能力</li>\n<li>~~ 面试，找工作。~~🤦‍♂️</li>\n</ol>\n<h2 id=\"举一个简单的算法例子\"><a href=\"#举一个简单的算法例子\" class=\"headerlink\" title=\"举一个简单的算法例子\"></a>举一个简单的算法例子</h2><p>大多数人都应该听说过著名数学家高斯的一个小故事：高斯在上小学的时候，老师布置了一个数学任务，让同学们对自然数从1到100求和。他很快就得出结果：5050。他的解释是这样的：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs apache\">    <span class=\"hljs-attribute\">num</span> = <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">3</span> + ... + <span class=\"hljs-number\">99</span> + <span class=\"hljs-number\">100</span>;<br>    <span class=\"hljs-attribute\">num</span> = <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">99</span> + ... + <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-attribute\">2</span> * num = <span class=\"hljs-number\">101</span> + <span class=\"hljs-number\">101</span> +... + <span class=\"hljs-number\">101</span> + <span class=\"hljs-number\">101</span>; // 一共<span class=\"hljs-number\">100</span>个<span class=\"hljs-number\">101</span>相加<br>    <span class=\"hljs-attribute\">num</span> = <span class=\"hljs-number\">101</span> * <span class=\"hljs-number\">100</span> / <span class=\"hljs-number\">2</span> = <span class=\"hljs-number\">5050</span>；<br></code></pre></div></td></tr></table></figure>\n\n<p>这道题如果用代码来实现的话，有两种解法：</p>\n<ol>\n<li><strong>普通解法</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">computeSum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; i++) &#123;<br>        sum += i;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<ol start=\"2\">\n<li><strong>高斯的解法</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">computeSum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum =  (<span class=\"hljs-number\">1</span> + n) * n / <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<p>即使我们没有学过算法，我们也能看出来，这两种计算方法，第二种显然更加的高效，但是如果让我们来评价第二种算法有多高效，它的<strong>时间复杂度</strong>是多少，<strong>空间复杂度</strong>是多少，可能就需要我们了解一些算法的度量方法之后，才能准确的表达出来。</p>\n<hr>\n<p>下面我们从算法的定义，特性，要求，度量方法来完整的了解一下算法</p>\n<h2 id=\"算法的定义\"><a href=\"#算法的定义\" class=\"headerlink\" title=\"算法的定义\"></a>算法的定义</h2><blockquote>\n<p>“<strong>算法是描述解决问题的方法。</strong>算法（Algorithm）这个单词最早出现在波斯数学家阿勒·花刺子密在公元825年（相当于我们中国的唐朝时期）所写的《印度数字算术》中。如今普遍认可的对算法的定义是：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”</p>\n</blockquote>\n<h2 id=\"算法的特性\"><a href=\"#算法的特性\" class=\"headerlink\" title=\"算法的特性\"></a>算法的特性</h2><p>算法有五个基本特性：输入、输出、有穷性，确定性和可行性。</p>\n<ol>\n<li><strong>输入：</strong>待解决问题的条件，一般来说，一个算法会有一个或多个输入参数。（也可以是零个输入参数，如：打印hello world）</li>\n<li><strong>输出：</strong> 待解决问题的结果，输出的形式可能是打印控制台，或者返回一个数据。一个算法一定至少有一个输出。</li>\n<li><strong>有穷性：</strong> 指的是解决问题的步骤，必须是有限的。从我们写代码角度来理解的话，就是不能出现死循环。这个有限的步骤，也是有一定边界的，如果我们写了一个算法，需要一百年才能计算出结果，虽然说步骤可能是有限的，但是就算一百年不断电，一百年之后谁能验证这个结果是否正确呢😂，所以说这个“有限”，一定要合理。</li>\n<li><strong>确定性：</strong>相同的输入只能有唯一的结果，算法的每一步骤的意义都被精确定义而无歧义；</li>\n<li><strong>可行性：</strong>算法必须可以被实现。也就是说它每一步都必须可以转换为程序上机运行，并且得到正确结果。</li>\n</ol>\n<h2 id=\"算法的要求\"><a href=\"#算法的要求\" class=\"headerlink\" title=\"算法的要求\"></a>算法的要求</h2><p>评价一个算法是否有效，是不是够好，有四个指标：正确性、可读性、健壮性、时间效率高和存储量低.</p>\n<ol>\n<li><strong>正确性</strong>：这是一个算法最基本的条件，它指的是，算法至少应该根据问题的描述和输入，得到一个正确的输出。</li>\n<li><strong>可读性</strong>：算法设计的另一目的是为了便于阅读、理解和交流。（个人理解，这个指标的优先级在其他三个指标之后）</li>\n<li><strong>健壮性</strong>：当输入不合法的参数，我们要保证我们的算法可以正常执行，并返回结果，而不是直接程序报错。</li>\n<li><strong>时间效率高和存储量低</strong>： 这是评估一个算法是不是好的算法的指标，指的是这个算法执行的时间是不是足够短，消耗的内存是不是足够小。</li>\n</ol>\n<p>总的来说，一个有效算法必须满足正确性和健壮性，如果同时能满足时间效率高和存储量低以及可读性，那么它就是一个有效的，并且是一个优秀的算法。</p>\n<h2 id=\"算法的度量方法\"><a href=\"#算法的度量方法\" class=\"headerlink\" title=\"算法的度量方法\"></a>算法的度量方法</h2><p>算法的度量方法有两种：1. 事后统计法；2. 事前估算法</p>\n<h3 id=\"事后统计法\"><a href=\"#事后统计法\" class=\"headerlink\" title=\"事后统计法\"></a>事后统计法</h3><p>事前统计法，主要是通过一批固定的测试数据，让不同算法的程序去执行，得到结果后，统计出不同算法的结果进行统计分析来判断不同算法的效率高低。<br>虽然这样也可以计算出算法的效率高低。但是它的缺点也很明显：</p>\n<ul>\n<li>硬件要求完全一致；</li>\n<li>测试数据设计困难，测试数据必须考虑的足够全面；</li>\n<li>如果算法比较复杂，这个统计的时间可能会需要很久；</li>\n</ul>\n<p>所以一般来说，我们一般不考虑用这种方法来度量算法</p>\n<h3 id=\"事前估算法\"><a href=\"#事前估算法\" class=\"headerlink\" title=\"事前估算法\"></a>事前估算法</h3><p>先来看一下影响程序执行效率的因素：1.硬件；2.编译器；3.程序指令的执行次数；4.问题的条件和输入；<br>通过分析我们发现，第1，2，4个因素都是算法无法影响的，所以我们只关注程序代码，那么我们再回到上面那道题，计算1-100的和，我们看一下两种算法的程序代码</p>\n<ol>\n<li><strong>普通解法</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">computeSum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//执行1次</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; i++) &#123; <span class=\"hljs-comment\">//int i = 1执行1次，i &lt; n 执行 n 次，i++ 执行 n 次</span><br>        sum += i; <span class=\"hljs-comment\">//执行n次</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<p>整个程序代码一共执行了 1+1+n+n+n+n=4n+2次<br>2. <strong>高斯的解法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">computeSum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum =  (<span class=\"hljs-number\">1</span> + n) * n / <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 执行1次</span><br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<p>整个程序代码一共执行了 1次</p>\n<p><strong>所以，显而易见，1 &lt; 4n+2,第二种算法执行效率更高</strong>，第一种的时间复杂度，我们记作O(n),表示线性阶，第二种时间复杂度，我们计作O(1)，表示常数阶；</p>\n<h2 id=\"算法的时间复杂度\"><a href=\"#算法的时间复杂度\" class=\"headerlink\" title=\"算法的时间复杂度\"></a>算法的时间复杂度</h2><blockquote>\n<p>“在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。<br>这样用大写O( )来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。”<br>——摘录来自: 程杰. “大话数据结构。” </p>\n</blockquote>\n<p>简单理解，算法的时间复杂度和语句执行的次数紧密相关，如上面的提到的普通解法的算法执行次数:4n+2,我们用O(n)表示这个算法的时间复杂度。为什么不是O(4n+2)，或者O(4n)? 接着看下面的推导大O阶的方法：</p>\n<blockquote>\n<p>1．用常数1取代运行时间中的所有加法常数。<br>2．在修改后的运行次数函数中，只保留最高阶项。<br>3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。取最高阶的项并忽略其常系数<br>——摘录来自: 程杰. “大话数据结构。” </p>\n</blockquote>\n<p>接下来说为什么上面那个算法的执行次数是4n+2，但它的时间复杂度是O(n),<br>根据推导大O的方法1，可以得到 4n + 2 = O(4n + 1)；<br>根据推导大O的方法2，只保留最高阶，4n + 2 =O(4n);<br>根据推导大O的方法3，最高阶项是4n，那么4n相乘的常熟是4，就需要除以4，最终结果是 4n + 2 = O(4n / 4) = O(n);</p>\n<p>下面是常见的时间复杂度及例子</p>\n<table>\n<thead>\n<tr>\n<th>函数阶</th>\n<th>非正式术语</th>\n<th>执行次数的例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>O(1)</td>\n<td>常数阶</td>\n<td>1,2,12</td>\n</tr>\n<tr>\n<td>O(n)</td>\n<td>线性阶</td>\n<td>4n+2,2n+1,n+10</td>\n</tr>\n<tr>\n<td>O(n<sup>2</sup>)</td>\n<td>平方阶</td>\n<td>3n2+2n+1</td>\n</tr>\n<tr>\n<td>O(logn)</td>\n<td>对数阶</td>\n<td>5log2n+20</td>\n</tr>\n<tr>\n<td>O(nlogn)</td>\n<td>nlogn阶</td>\n<td>2n+3nlog2n+19</td>\n</tr>\n<tr>\n<td>O(n<sup>3</sup>)</td>\n<td>立方阶</td>\n<td>6n<sup>3</sup>+2n+3n+4</td>\n</tr>\n<tr>\n<td>O(2<sup>n</sup>)</td>\n<td>指数阶</td>\n<td>2<sup>n</sup></td>\n</tr>\n<tr>\n<td>O(n!)</td>\n<td>–</td>\n<td>无</td>\n</tr>\n<tr>\n<td>O(n<sup>n</sup>)</td>\n<td>–</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<p>最后两种时间复杂度很少用到，常用的时间复杂度所耗费的时间从小到大依次是：<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><blockquote>\n<p>“一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)”<br>——摘录来自: 程杰. “大话数据结构。” </p>\n</blockquote>\n<p>空间复杂度一般我们也用大O来表示，问题的输入、条件、输出变量取决于问题，所以不算做算法本身的存储空间，算法的存储空间只和其他的辅助变量有关。只要辅助变量的数量是常数，也就是说空间复杂度为O(1),那么这个算法就可以称为<strong>原地工作</strong>，原地工作这个词在leetcode题目中可能会出现。</p>\n<p>对于算法的空间复杂度一般来说讲的比较少，计算机内存越来越大了，只要不是特别离谱，我们一般情况下，可能会故意通过空间来换时间，像系统设计中的缓存，就是很好的例子，所以空间复杂度我们大概了解就行，不过多在介绍了。</p>\n<h2 id=\"一张脑图概括\"><a href=\"#一张脑图概括\" class=\"headerlink\" title=\"一张脑图概括\"></a>一张脑图概括</h2><p>好了最后我们用一张图来总结一下这篇文章的内容</p>\n<p>。。。<br>。。。<br>图片加载失败……<br><del>我只是困了想睡觉了🤦‍♂️</del></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是算法？\"><a href=\"#什么是算法？\" class=\"headerlink\" title=\"什么是算法？\"></a>什么是算法？</h2><blockquote>\n<p>“算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”<br>——摘录来自: 程杰. “大话数据结构。”</p>\n</blockquote>","more":"<p>我个人理解，算法就是解决某一类问题的方法。我们的前辈总结了非常多优秀的算法，比如用于排序的冒泡排序、选择排序、插入排序算法，用于查找的二分查找、散列查找、顺序查找算法等。</p>\n<h2 id=\"为什么要学习算法？\"><a href=\"#为什么要学习算法？\" class=\"headerlink\" title=\"为什么要学习算法？\"></a>为什么要学习算法？</h2><ol>\n<li>算法是编程的基础，不管学习什么语言，算法早晚要学的，它是我们进阶到高级开发工程师所必须要掌握的知识之一。</li>\n<li>可以培养自己写出高效的代码</li>\n<li>锻炼自己的逻辑思维能力</li>\n<li>~~ 面试，找工作。~~🤦‍♂️</li>\n</ol>\n<h2 id=\"举一个简单的算法例子\"><a href=\"#举一个简单的算法例子\" class=\"headerlink\" title=\"举一个简单的算法例子\"></a>举一个简单的算法例子</h2><p>大多数人都应该听说过著名数学家高斯的一个小故事：高斯在上小学的时候，老师布置了一个数学任务，让同学们对自然数从1到100求和。他很快就得出结果：5050。他的解释是这样的：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\">    <span class=\"hljs-attribute\">num</span> = <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">3</span> + ... + <span class=\"hljs-number\">99</span> + <span class=\"hljs-number\">100</span>;<br>    <span class=\"hljs-attribute\">num</span> = <span class=\"hljs-number\">100</span> + <span class=\"hljs-number\">99</span> + ... + <span class=\"hljs-number\">3</span> + <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-attribute\">2</span> * num = <span class=\"hljs-number\">101</span> + <span class=\"hljs-number\">101</span> +... + <span class=\"hljs-number\">101</span> + <span class=\"hljs-number\">101</span>; // 一共<span class=\"hljs-number\">100</span>个<span class=\"hljs-number\">101</span>相加<br>    <span class=\"hljs-attribute\">num</span> = <span class=\"hljs-number\">101</span> * <span class=\"hljs-number\">100</span> / <span class=\"hljs-number\">2</span> = <span class=\"hljs-number\">5050</span>；<br></code></pre></td></tr></table></figure>\n\n<p>这道题如果用代码来实现的话，有两种解法：</p>\n<ol>\n<li><strong>普通解法</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">computeSum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; i++) &#123;<br>        sum += i;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><strong>高斯的解法</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">computeSum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum =  (<span class=\"hljs-number\">1</span> + n) * n / <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>即使我们没有学过算法，我们也能看出来，这两种计算方法，第二种显然更加的高效，但是如果让我们来评价第二种算法有多高效，它的<strong>时间复杂度</strong>是多少，<strong>空间复杂度</strong>是多少，可能就需要我们了解一些算法的度量方法之后，才能准确的表达出来。</p>\n<hr>\n<p>下面我们从算法的定义，特性，要求，度量方法来完整的了解一下算法</p>\n<h2 id=\"算法的定义\"><a href=\"#算法的定义\" class=\"headerlink\" title=\"算法的定义\"></a>算法的定义</h2><blockquote>\n<p>“<strong>算法是描述解决问题的方法。</strong>算法（Algorithm）这个单词最早出现在波斯数学家阿勒·花刺子密在公元825年（相当于我们中国的唐朝时期）所写的《印度数字算术》中。如今普遍认可的对算法的定义是：算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。”</p>\n</blockquote>\n<h2 id=\"算法的特性\"><a href=\"#算法的特性\" class=\"headerlink\" title=\"算法的特性\"></a>算法的特性</h2><p>算法有五个基本特性：输入、输出、有穷性，确定性和可行性。</p>\n<ol>\n<li><strong>输入：</strong>待解决问题的条件，一般来说，一个算法会有一个或多个输入参数。（也可以是零个输入参数，如：打印hello world）</li>\n<li><strong>输出：</strong> 待解决问题的结果，输出的形式可能是打印控制台，或者返回一个数据。一个算法一定至少有一个输出。</li>\n<li><strong>有穷性：</strong> 指的是解决问题的步骤，必须是有限的。从我们写代码角度来理解的话，就是不能出现死循环。这个有限的步骤，也是有一定边界的，如果我们写了一个算法，需要一百年才能计算出结果，虽然说步骤可能是有限的，但是就算一百年不断电，一百年之后谁能验证这个结果是否正确呢😂，所以说这个“有限”，一定要合理。</li>\n<li><strong>确定性：</strong>相同的输入只能有唯一的结果，算法的每一步骤的意义都被精确定义而无歧义；</li>\n<li><strong>可行性：</strong>算法必须可以被实现。也就是说它每一步都必须可以转换为程序上机运行，并且得到正确结果。</li>\n</ol>\n<h2 id=\"算法的要求\"><a href=\"#算法的要求\" class=\"headerlink\" title=\"算法的要求\"></a>算法的要求</h2><p>评价一个算法是否有效，是不是够好，有四个指标：正确性、可读性、健壮性、时间效率高和存储量低.</p>\n<ol>\n<li><strong>正确性</strong>：这是一个算法最基本的条件，它指的是，算法至少应该根据问题的描述和输入，得到一个正确的输出。</li>\n<li><strong>可读性</strong>：算法设计的另一目的是为了便于阅读、理解和交流。（个人理解，这个指标的优先级在其他三个指标之后）</li>\n<li><strong>健壮性</strong>：当输入不合法的参数，我们要保证我们的算法可以正常执行，并返回结果，而不是直接程序报错。</li>\n<li><strong>时间效率高和存储量低</strong>： 这是评估一个算法是不是好的算法的指标，指的是这个算法执行的时间是不是足够短，消耗的内存是不是足够小。</li>\n</ol>\n<p>总的来说，一个有效算法必须满足正确性和健壮性，如果同时能满足时间效率高和存储量低以及可读性，那么它就是一个有效的，并且是一个优秀的算法。</p>\n<h2 id=\"算法的度量方法\"><a href=\"#算法的度量方法\" class=\"headerlink\" title=\"算法的度量方法\"></a>算法的度量方法</h2><p>算法的度量方法有两种：1. 事后统计法；2. 事前估算法</p>\n<h3 id=\"事后统计法\"><a href=\"#事后统计法\" class=\"headerlink\" title=\"事后统计法\"></a>事后统计法</h3><p>事前统计法，主要是通过一批固定的测试数据，让不同算法的程序去执行，得到结果后，统计出不同算法的结果进行统计分析来判断不同算法的效率高低。<br>虽然这样也可以计算出算法的效率高低。但是它的缺点也很明显：</p>\n<ul>\n<li>硬件要求完全一致；</li>\n<li>测试数据设计困难，测试数据必须考虑的足够全面；</li>\n<li>如果算法比较复杂，这个统计的时间可能会需要很久；</li>\n</ul>\n<p>所以一般来说，我们一般不考虑用这种方法来度量算法</p>\n<h3 id=\"事前估算法\"><a href=\"#事前估算法\" class=\"headerlink\" title=\"事前估算法\"></a>事前估算法</h3><p>先来看一下影响程序执行效率的因素：1.硬件；2.编译器；3.程序指令的执行次数；4.问题的条件和输入；<br>通过分析我们发现，第1，2，4个因素都是算法无法影响的，所以我们只关注程序代码，那么我们再回到上面那道题，计算1-100的和，我们看一下两种算法的程序代码</p>\n<ol>\n<li><strong>普通解法</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">computeSum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//执行1次</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; i++) &#123; <span class=\"hljs-comment\">//int i = 1执行1次，i &lt; n 执行 n 次，i++ 执行 n 次</span><br>        sum += i; <span class=\"hljs-comment\">//执行n次</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>整个程序代码一共执行了 1+1+n+n+n+n=4n+2次<br>2. <strong>高斯的解法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">computeSum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum =  (<span class=\"hljs-number\">1</span> + n) * n / <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 执行1次</span><br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>整个程序代码一共执行了 1次</p>\n<p><strong>所以，显而易见，1 &lt; 4n+2,第二种算法执行效率更高</strong>，第一种的时间复杂度，我们记作O(n),表示线性阶，第二种时间复杂度，我们计作O(1)，表示常数阶；</p>\n<h2 id=\"算法的时间复杂度\"><a href=\"#算法的时间复杂度\" class=\"headerlink\" title=\"算法的时间复杂度\"></a>算法的时间复杂度</h2><blockquote>\n<p>“在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。<br>这样用大写O( )来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。”<br>——摘录来自: 程杰. “大话数据结构。” </p>\n</blockquote>\n<p>简单理解，算法的时间复杂度和语句执行的次数紧密相关，如上面的提到的普通解法的算法执行次数:4n+2,我们用O(n)表示这个算法的时间复杂度。为什么不是O(4n+2)，或者O(4n)? 接着看下面的推导大O阶的方法：</p>\n<blockquote>\n<p>1．用常数1取代运行时间中的所有加法常数。<br>2．在修改后的运行次数函数中，只保留最高阶项。<br>3．如果最高阶项存在且不是1，则去除与这个项相乘的常数。取最高阶的项并忽略其常系数<br>——摘录来自: 程杰. “大话数据结构。” </p>\n</blockquote>\n<p>接下来说为什么上面那个算法的执行次数是4n+2，但它的时间复杂度是O(n),<br>根据推导大O的方法1，可以得到 4n + 2 = O(4n + 1)；<br>根据推导大O的方法2，只保留最高阶，4n + 2 =O(4n);<br>根据推导大O的方法3，最高阶项是4n，那么4n相乘的常熟是4，就需要除以4，最终结果是 4n + 2 = O(4n / 4) = O(n);</p>\n<p>下面是常见的时间复杂度及例子</p>\n<table>\n<thead>\n<tr>\n<th>函数阶</th>\n<th>非正式术语</th>\n<th>执行次数的例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>O(1)</td>\n<td>常数阶</td>\n<td>1,2,12</td>\n</tr>\n<tr>\n<td>O(n)</td>\n<td>线性阶</td>\n<td>4n+2,2n+1,n+10</td>\n</tr>\n<tr>\n<td>O(n<sup>2</sup>)</td>\n<td>平方阶</td>\n<td>3n2+2n+1</td>\n</tr>\n<tr>\n<td>O(logn)</td>\n<td>对数阶</td>\n<td>5log2n+20</td>\n</tr>\n<tr>\n<td>O(nlogn)</td>\n<td>nlogn阶</td>\n<td>2n+3nlog2n+19</td>\n</tr>\n<tr>\n<td>O(n<sup>3</sup>)</td>\n<td>立方阶</td>\n<td>6n<sup>3</sup>+2n+3n+4</td>\n</tr>\n<tr>\n<td>O(2<sup>n</sup>)</td>\n<td>指数阶</td>\n<td>2<sup>n</sup></td>\n</tr>\n<tr>\n<td>O(n!)</td>\n<td>–</td>\n<td>无</td>\n</tr>\n<tr>\n<td>O(n<sup>n</sup>)</td>\n<td>–</td>\n<td>无</td>\n</tr>\n</tbody></table>\n<p>最后两种时间复杂度很少用到，常用的时间复杂度所耗费的时间从小到大依次是：<br>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n<sup>2</sup>) &lt; O(n<sup>3</sup>) &lt; O(2<sup>n</sup>) &lt; O(n!) &lt; O(n<sup>n</sup>)</p>\n<h2 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h2><blockquote>\n<p>“一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)”<br>——摘录来自: 程杰. “大话数据结构。” </p>\n</blockquote>\n<p>空间复杂度一般我们也用大O来表示，问题的输入、条件、输出变量取决于问题，所以不算做算法本身的存储空间，算法的存储空间只和其他的辅助变量有关。只要辅助变量的数量是常数，也就是说空间复杂度为O(1),那么这个算法就可以称为<strong>原地工作</strong>，原地工作这个词在leetcode题目中可能会出现。</p>\n<p>对于算法的空间复杂度一般来说讲的比较少，计算机内存越来越大了，只要不是特别离谱，我们一般情况下，可能会故意通过空间来换时间，像系统设计中的缓存，就是很好的例子，所以空间复杂度我们大概了解就行，不过多在介绍了。</p>\n<h2 id=\"一张脑图概括\"><a href=\"#一张脑图概括\" class=\"headerlink\" title=\"一张脑图概括\"></a>一张脑图概括</h2><p>好了最后我们用一张图来总结一下这篇文章的内容</p>\n<p>。。。<br>。。。<br>图片加载失败……<br><del>我只是困了想睡觉了🤦‍♂️</del></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckqhrqigz0003t0uv3uddgo94","category_id":"ckqhrqih00004t0uvbqqs84uz","_id":"ckqhrqih30007t0uv1a8r5hsx"}],"PostTag":[{"post_id":"ckqhrqigz0003t0uv3uddgo94","tag_id":"ckqhrqih20005t0uv0ss812r0","_id":"ckqhrqih30008t0uveehrf3dk"},{"post_id":"ckqhrqigz0003t0uv3uddgo94","tag_id":"ckqhrqih20006t0uvdt7g68mb","_id":"ckqhrqih30009t0uvauic544j"}],"Tag":[{"name":"学习笔记","_id":"ckqhrqih20005t0uv0ss812r0"},{"name":"数据结构与算法","_id":"ckqhrqih20006t0uvdt7g68mb"}]}}